# Scheme-PLUS-for-Racket
Scheme+ for DrRacket by Damien Mattei.

Install as a package with the [package manager](https://pkgs.racket-lang.org/package/Scheme-PLUS-for-Racket) (could be a 24 hours delay from github.com to pkgs.racket-lang.org) or from Github source code.

The documentation is here, but is a bit outdated:
https://github.com/damien-mattei/Scheme-PLUS-for-Racket/blob/gh-pages/README.md

Designed to use with [SRFI 105 Curly Infix reader for Racket](https://github.com/damien-mattei/SRFI-105-for-Racket).

![Scheme+ schema](https://github.com/damien-mattei/Scheme-PLUS-for-Kawa/blob/main/schema-scheme%2B.jpg "Scheme+ schema")


With Racket you do not need to define/declare a variable with the
Scheme+ operator <+. Because the binding of the variable is autodetect
you can simply set the variable with <- (or :=) and Scheme+ will do the job.


The Racket GUI can not display the line of error in a Scheme+ program.
If you have to debug your source code you must generate a Scheme file
from your Scheme+ file with curly-infix2prefix4racket and load the
result file in Racket GUI. Then you will have all the debug
information of Racket on the scheme file.Another solution is to simply copy/paste the pure Racket
code generated by the SRFI 105 Curly Infix parser and run it like a normal Racket program.
Again you will have all the information about errors with the true line number displayed.
Another method is to use the [Makefile](https://github.com/damien-mattei/Scheme-PLUS-for-Racket/blob/main/examples/racket/Makefile) provided (see docs).



**Changes of version 11.3:**

Remove the need of pragma for strict SRFI-105 mode by autodetecting the strict syntax and the required application in context.
Example:
```scheme
(define (cinque) 5)
(define (minus) -)
{(cinque) + {(cinque) (minus) 3}}
(+ (cinque) ((minus) (cinque) 3)) ; parsed result displayed
7
```

Better detection of infix mode allowing some sort of expressions to be detected as infix even if we have procedures as operands:

```scheme
(define (cinque) 5)
(define (tre) 3)
(define (due) 2)
{(cinque) * (tre) - (due)}

(- (* (cinque) (tre)) (due)) ; parsed result displayed
13

#<eof>
```


<br>

**Changes of version 11.0:**

Less syntax transformers used.Infix to prefix with operator precedence is now done by default in the reader parser stage. This result in better compatiblity with other language that change the syntax, for example it should be compatible with Qi (even if not tested).Also the external parsing allows extended features with superscripted syntax with not only constants but variables too.
Example:
```scheme
(define (foo) (define n 3) {3 ⁻²·⁽ⁿ⁻⁴⁾})
(foo)
9
```




**Changes of version 10.8:**

Only internal changes in code. Prepare for a greater upgrade.Moved some n-arity code use from nfx to infix-with-precedence-to-prefix module.
Updated relatively with the code changes the personal internal documentation design of Scheme+ which is hosted in the Kawa Scheme+ project for historical reason.


**Changes of version 10.7:**

No change in API but i removed depandancies between Scheme+  and SRFI-105-curly-infix that was alternating-parameters procedure. The procedure is now duplicated like it was in old versions. This is not elegant but remove dependancies that would lead in future version when i will use more scheme+ procedure in SRFI-105 parser in fatal circular dependancies.


**Changes of version 10.5:**

Correct some typos about assignment operators.(strangely a line was commented)

Check that infix code is correct before parsing it to prefix.(previously some wrong code could have been truncated by the parser to the most great valid expression)


**Changes of version 10.4:**

Correct a bug that ommiting assignment operators (```<- := -> =:```) from being correctly detected as infix in the case the first argument is a procedure which is arising with Racket's contracts.

Example:

```
{positive-integer? -> (listof positive-integer-triplet?)}
```

The bug was also preventing a known scheme procedure to be re-assigned (note that by definition procedure are immutable in a Racket module), example now working:

```
(define (my-cons a b) (display "hello from my-cons") (newline) (cons a b))
(declare a-new-cons)
{a-new-cons := my-cons}
(a-new-cons "hello" "world")
```

```
hello from my-cons
'("hello" . "world")
```

Note for reader: i apologize because perheaps this summary is not clear. At least for Racket's contract i have to update Scheme+ and the pragmas code of SRFI-105.


Deprecate ```range.rkt``` module providing ```in-range``` and ```reversed``` as ```in-range``` is already existing for stream in Racket and was conflicting and used as list which is already done by ```range``` from ```racket/list```. ```reversed``` was just ```reverse``` and was just named the same way as in Python for porting code.

Added some more examples and update code examples according to this release.



**New feature of version 10.3:**

Allow multiples In/equalities in expression, examples:


```scheme

(when {0 ≤ x0 ≤ xws  and 0 ≤ x1 ≤ xws and
       0 ≤ y0 ≤ ywsp and 0 ≤ y1 ≤ ywsp}
     (send dc draw-line
		   x0 y0
		   x1 y1))

{#t and (#f or 1 < 2 <= 2)}
#t

{#t and (#f or 1 < 2 < 2)}
#f

(in/equalities-state-1 '(x + 2 < 3 and a + 1 < 3 * b <= c - 1 < d + 2 or y * 3 > 4 and f and 1 < 2 < 3)  '() '() '()  '())
'(x + 2 < 3 and ((a + 1) < (3 * b) <= (c - 1) < (d + 2)) or y * 3 > 4 and f and (1 < 2 < 3))

```

I present some features of scheme+ for racket that allow the melting in an expression of both infix and prefix sub-expressions. 
There is a disambiguating algorithm based on a finite state machine. 
Note that some expression would need to be detected not only at the syntax parsing but at the execution stage.(which is not yet implemented,will be in future version).

This feature allow to get rid of use of special { } curly brackets as it is now auto-detected by scheme syntax transformers, and so you just have to use normal ( ) parenthesis. 
But then you have to use a special definition procedure called `define+` but i have modified in scheme+ the classic `define` of scheme to integrate in it the `define+` special feature, still with 100% compatibility with scheme. So you rarely have to use `define+`.
As there is no more needs to use { } you can get rid of the use of `#lang reader SRFI-105` if you just use the infix/prefix syntax, but if you want to use the indexing via [  ] yo still need the SRFI-105 parser.

Note that it could be strange to mix infix and prefix sub-expressions in an expression it is more logic to keep the same syntax in all the expression. It just could be possible because the algorithm is recursive and check the syntax for all the sub expressions, allowing the mix

Here is some concrete examples:

Note that i really prefer for infix definitions a syntax like `{x := infix_expressions ...}` instead of `(define x infix_expressions ...)` 

```scheme
Welcome to DrRacket, version 8.17 [cs].
Language: racket, with debugging; memory limit: 14000 MB.
> (require Scheme+)

Scheme+ v10.0 by Damien Mattei

(define x  3 * 5 + 2)
x
17

(define t  3 * (+ 2 4) - 1)
t
17

(define z  (3 + 1) * (2 * (+ 2 1) - (sin 0.3)) + ((* 2 5) - 5))
z
27.817919173354642

(define x  1 + 2 + 3)
x
6

(define k  10.0 - 3.0 - 4.0 + 1 - 5.0 * 2.0 ** 3.0 / 7.0 ** 3.0)
k
3.883381924198251

(define a 7)
(define b 3)
(define r  a * - b)
r
-21

(define s  3 ² + 2 · 3 · 5 + 5 ²)
 s
64

(define s  3 ² + 2 * 3 * 5 + 5 ²)
s
64

```



And here is a simple list of  examples or piece of code tested or running REPL-SRFI-105-Racket.rkt :  

```scheme
Welcome to DrRacket, version 8.14 [cs].
Language: reader SRFI-105, with debugging; memory limit: 8192 MB.
SRFI 105 Curly Infix for Scheme+ v9.8
SRFI-105 Curly Infix parser for Racket Scheme and R6RS by Damien MATTEI
(based on code from David A. Wheeler and Alan Manuel K. Gloria.)

Possibly skipping some header's lines containing space,tabs,new line,etc  or comments.

SRFI-105.rkt : number of skipped lines (comments, spaces, directives,...) at header's beginning : 12

Parsed curly infix code result = 

(module repl racket (provide (all-defined-out)) (require Scheme+))

Scheme+ v10.0 by Damien Mattei

;; examples in REPL begins here:
{3 * (+ 2 4) - 1}
17

{(- 7 (3 * (+ 2 4) - 1))}
-10

{(3 + 1) * (2 * (+ 2 1) - sin(0.3)) + ((* 2 5) - 5)}
27.817919173354642
;; the above is in prefix : (+ (* (+ 3 1) (- (* 2 (+ 2 1)) (sin 0.3))) (- (* 2 5) 5))

(define n 7)
{2 * (- n 4)}
6

(define a 3)
(define b 5)
{n + (- b a)}
9



```


Here is a few more syntax available in this version of Scheme+ with SRFI-105 reader: 

```scheme
#lang SRFI-105
(require Scheme+)
```

```scheme
(define (foo x y) {-4 · sin(x) + x · y ² - 5 · x / y})
(foo 1.23 3.4)
8.640021262861444

{2 ³}
8

{3 · (2 ³ - 1)}
21

{(2 ³) ⁴}
4096

(define+ (chaos p q d x0 y0)
  
  ;;(define a {2 * cos{2 * pi * p / q}}) ; or {2 * (cos {2 * pi * p / q})} or {2 * cos({2 * pi * p / q})}
  (define a   2 * (cos (2 * pi * p / q)))
  (define+ ksx  (√ ((2 + a) / 2)) ) ;; (sqrt {(2 + a) / 2})) ; or sqrt{{2 + a} / 2}
  {ksy := (√ ((2 - a) / 2))}    ; (sqrt {(2 - a) / 2})} ; or (define ksy (sqrt {{2 - a} / 2}))
  
  (stream-map (lambda (z)
                (match-let (((vector x y) z))
                  (vector ((ksx / (√ 2)) * (x + y))
			  {(ksy / (√ 2)) * ((- x) + y)})))
                  (stream-iterate (lambda (z)
                                    (match-let (((vector x y) z))
                                      (vector
                                       ;;((a * x) + y + (d * x) / (add1 (x ** 2))) ; infix left to right evaluation avoid extra parenthesis but is hard for humans
				       ((a * x) + y + (d * x) / (add1 (x ²)))
				       (- x))))
				  (vector x0 y0))))


(define+ (line-length x0 y0 x1 y1)
  (√ ((x1 - x0) ² + (y1 - y0) ²)))
```
