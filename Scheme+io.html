<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="Scheme+io_fichiers/style.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->
    <!-- Setup theme-color -->
    <!-- start theme color meta headers -->
    <meta name="theme-color" content="#151515">
    <meta name="msapplication-navbutton-color" content="#151515">
    <meta name="apple-mobile-web-app-status-bar-style"
      content="black-translucent">
    <!-- end theme color meta headers -->
    <!-- Setup Google Analytics -->
    <!-- You can set your favicon here -->
    <!-- link rel="shortcut icon" type="image/x-icon" href="/Scheme-PLUS-for-Racket/favicon.ico" -->
    <!-- end custom head snippets -->
    <!-- Begin Jekyll SEO tag v2.8.0 -->
    <title>[“Scheme+ programing language by Damien Mattei”] |
      [“Enhancing Scheme (and Lisp-like) languages.”]</title>
    <meta name="generator" content="Jekyll v3.9.0">
    <meta property="og:title" content="[“Scheme+ programing language by
      Damien Mattei”]">
    <meta property="og:locale" content="en_US">
    <meta name="description" content="[“Enhancing Scheme (and Lisp-like)
      languages.”]">
    <meta property="og:description" content="[“Enhancing Scheme (and
      Lisp-like) languages.”]">
    <link rel="canonical"
      href="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/">
    <meta property="og:url"
      content="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/">
    <meta property="og:site_name" content="[“Scheme+ programing language
      by Damien Mattei”]">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary">
    <meta property="twitter:title" content="[“Scheme+ programing
      language by Damien Mattei”]">
    <script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"[“Enhancing Scheme (and Lisp-like) languages.”]","headline":"[“Scheme+ programing language by Damien Mattei”]","name":"[“Scheme+ programing language by Damien Mattei”]","url":"https://damien-mattei.github.io/Scheme-PLUS-for-Racket/"}</script>
    <!-- End Jekyll SEO tag -->
  </head>
  <body>
    <header>
      <div class="container"> <a id="a-title"
          href="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/">
          <h1>Scheme+ programing language by Damien Mattei</h1>
        </a>
        <h2>Enhancing Scheme (and Lisp-like) languages.</h2>
        <section id="downloads"> <a
href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/zipball/main"
            class="btn">Download as .zip</a> <a
href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/tarball/main"
            class="btn">Download as .tar.gz</a> <a
            href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket"
            class="btn btn-github"><span class="icon"></span>View on
            GitHub</a> </section>
      </div>
    </header>
    <div class="container">
      <section id="main_content">
        <p> <br>
        </p>
        <div align="center"> <br>
        </div>
        <div align="center"><img moz-do-not-send="true"
            src="Scheme+io_fichiers/Scheme.png" title="by Damien MATTEI"
            alt="Scheme+" width="290" height="65"></div>
        <h2 style="text-align: center;"><span style="color: #00cccc;"><i>Enhancing

              Scheme (and Lisp-like) language. </i></span></h2>
        <h2 style=" text-align: center;">Damien Mattei<br>
        </h2>
        <p style="text-align: center;"><i><br>
          </i></p>
        <p style="text-align: center;"><i>"Doubts are such tiny things.
            A mind with no room for doubts must have no room for
            thoughts either."</i> -<a
            href="https://www.ics.uci.edu/%7Epattis/" target="_blank">R.
            Patti</a></p>
        <p style="text-align: center;"><br>
        </p>
        <h1 style="text-align: center;"><b><span style="color: #000099;">Scheme+</span></b><b><span
              style="color: #999999;"> <font size="+2">version 5.0 for
                Racket Scheme<br>
              </font></span></b></h1>
        <p style="text-align: center;"> Display options for viewing this
          documentation:<br>
          <br>
          <a
href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/blob/main/README.md">Click
            here for a larger page view that improve code display.</a> <br>
          <br>
          <a
href="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/Scheme+.html">Click
            here for the light HTML page version of this page.</a> <br>
          <br>
          <a
href="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/Scheme+io.html">Click

            here for the dark Hacker Theme version of this page.</a> </p>
        <p><br>
        </p>
        <h2><u>1. Scheme+ at a glance:&nbsp;</u></h2>
        <p><b>Scheme+ is an extension of the syntax of the <a
              href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29"
              target="_blank">Scheme</a> language.</b><br>
        </p>
        <p><b>Scheme+ makes it easy the assignment of Scheme objects </b><b>in

            infix </b><b>(works also in prefix) </b><b>notation </b><b>with
            a few new operators&nbsp;</b><b> </b><b><b><b>← (or&nbsp;</b></b>
            &lt;-), [ ],</b><b><font size="+2">⥆ </font>(or &lt;+) . </b><br>
        </p>
        <p><b>The idea of Scheme+ first come to my mind when comparing
            the assignation syntax used in Clojure with Scheme and Lisp,
            and later the easyness of creating and assigning variables
            in Python completely convince me that the Scheme system have
            to be enhanced.</b><br>
        </p>
        <p>The <b>idea</b> of <b>Scheme+</b> is also came from this :
          <b> <i>"Why is it so boring to define variables in Scheme
              with the traditionnal set of LET,LET*,LETREC,LET-VALUES
              special forms?"</i></b> and <b><i>"Is it possible to use
              a single mechanism for assignment in Scheme?"</i></b></p>
        <p>It comes also from the ascertainment that <i><b>"A computer
              language is created by ONE man, later, a community only
              bring a library to the language without self-questioning
              any more on the fundations of language itself."</b></i></p>
        <p><i><b><br>
            </b></i></p>
        <p><i>Scheme+</i> is a Scheme module.</p>
        <p>Once loaded by inserting this in the header of the source
          file : <b>(require Scheme-PLUS-for-Racket/Scheme+)</b><br>
        </p>
        <p><i>Scheme+</i> brings syntax to classic <i>Scheme</i>
          language like those:</p>
        <p><br>
        </p>
        <p style="margin-left: 40px;"><b>{x &lt;- y} </b>infix
          assignment of the value of y to the variable x.</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">The same thing with a new symbol
          ←&nbsp; :&nbsp; (unicode 2190 in hexadecimal that can be enter
          under Linux with Ctrl-Shift u 2190 Enter or Space bar)</p>
	<p style="margin-left: 40px;"><b>{x ← y}</b></p>
	<p style="margin-left: 40px;"><b>With operator precedence: {xp <- {x - v * t} / (sqrt {1 - v ** 2 / c ** 2})}</b></p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">Assignment from right to left : <b>{y
            ← 7}</b></p>
        <p style="margin-left: 40px;">Assignment from left to right : <b>{7
            → y}</b></p>
        <p><font size="+3">⥆</font>&nbsp; or &lt;+ : Define and assign a
          new variable in the current environment ,example : <font
            size="+2">{v ⥆ 7}</font></p>
        <p style="margin-left: 40px;">
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
        </p>
        <p style="margin-left: 40px;">(unicode 2946 , on <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">Mac OS use </a>
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
          <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">CTRL+CMD+space to bring up the
            characters
            popover, </a>
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
          <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">then type in u+unicode (ex: u+2946)
            and hit Enter to
            get it</a>)<br>
          , and in Emacs you can insert an unicode char with the
          sequence:
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
          <code>‘C-x 8 RET’</code> followed with unicode of the
          character
          you want)<br>
          <br>
        </p>
        <p style="margin-left: 40px;"><b>{T[k]} </b>return value of
          vector or array T indexed by k.</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"><b>{T</b><b>[k] &lt;- x} </b>infix
          assignment of <b>T</b><b>[k] </b>with x.</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"><b>{T</b><b>[k] &lt;- </b><b><b>T</b><b>[{k
              + 1}]</b>} </b>in infix or the same with a little part of
          classic prefix Scheme:&nbsp; <b>{T</b><b>[k] &lt;- </b><b><b>T</b><b>[(+
              k 1)]</b>} <br>
          </b></p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">the same with multi dimensional
          arrays or matrix: <br>
          <b><b>{</b>T</b><b>[m n]} </b>return the value of the multi
          dimension array T indexed by m and n</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"><b><b>{</b>T</b><b>[m n] &lt;- </b><b><b>T</b><b>[m
              {n + 1}]</b>}</b></p>
        <p style="margin-left: 40px;"><br>
          <b><b>{</b>T</b><b>[m n] ← </b><b><b>T</b><b>[m {n + 1}]</b>}<br>
            <br>
          </b></p>
        <p style="margin-left: 40px;"><b>compatible with strings:</b></p>
        <p style="margin-left: 40px;"><b>{str &lt;+ (string-copy
            "hello")}<br>
          </b></p>
        <p style="margin-left: 40px;"><b>"hello"<br>
          </b></p>
        <p style="margin-left: 40px;"><b>{str[4]}<br>
          </b></p>
        <p style="margin-left: 40px;"><b>#\o<br>
          </b></p>
        <p style="margin-left: 40px;"><b>{str[4] &lt;- #\a}<br>
          </b></p>
        <p style="margin-left: 40px;"><b>#\a<br>
          </b></p>
        <p style="margin-left: 40px;"><b>str<br>
          </b></p>
        <p style="margin-left: 40px;"><b>"hella"</b></p>
        <br>
        <p style="margin-left: 40px;"><b>with function definition:</b></p>
        <p style="margin-left: 40px;"><b>(declare fact)<br>
            {fact &lt;- (λ (n) (if {n &lt;&gt; 0} {n * (fact {n - 1})}
            1))}<br>
          </b></p>
        <p style="margin-left: 40px;"><b>or just:<br>
          </b></p>
        <p style="margin-left: 40px;"><font size="+1"><b>{fact ⥆ (λ (n)
              (if
              {n &lt;&gt; 0} {n * (fact {n - 1})} 1))}</b></font></p>
        <p style="margin-left: 40px;"><b>{fact(8)}<br>
            40320<br>
          </b></p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"> no more need of <strike>LET,LET*,LETREC,LET-VALUES</strike>,...

        </p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"><b>←</b><b> is an n-arity
            operator, example :</b></p>
        <p style="margin-left: 40px;">(declare x y z t)<br>
          {x ← y ← z ← t ← 7}<br>
          &nbsp;7<br>
          &nbsp;(list x y z t)<br>
          &nbsp;(7 7 7 7)</p>
        <p style="margin-left: 40px;">Another example which build an
          identity matrix:</p>
        <p style="margin-left: 40px;">(require srfi/25)<br>
        </p>
        <p style="margin-left: 40px;">&nbsp;(declare I)<br>
          &nbsp;{I ← (make-array (shape 0 4 0 4))}<br>
          &nbsp; <br>
          &nbsp;&nbsp;&nbsp; <br>
          &nbsp;{I[0 0] ← I[1 1] ← I[2 2] ← I[3 3] ← 1}<br>
          &nbsp;1<br>
          &nbsp;&nbsp;&nbsp; <br>
          &nbsp;&nbsp;I<br>
          &nbsp; #&lt;array:srfi-9-record-type-descriptor&gt;</p>
        <p style="margin-left: 40px;">&gt; {I[0 0]}<br>
          1<br>
          &gt; {I[0 1]}<br>
          0<br>
        </p>
        <p style="margin-left: 40px;"><br>
          defining new functions with <b>def </b>instead of the
          classic define we can now use <b>return</b> to escape
          immediately from the current level of recursive call and <b>return-rec</b> to escape from the full stack of recursive calls :<br>
        </p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;"><b>(return)</b><br>
        </p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">or returning the value v: </p>
        <div style="margin-left: 40px;"> <b>(return </b>v<b>)</b></div>
        <p style="text-align: left;"><b> <br>
          </b></p>
        <p style="margin-left: 40px;">The &lt;+ operator works also for
          defining multiple values :<br>
        </p>
        <p style="margin-left: 40px;">{(a b c) &lt;+ (values 7 8 9)}<br>
          7<br>
          8<br>
          9<br>
          (list a b c)<br>
          '(7 8 9)<br>
        </p>
        <p style="margin-left: 40px;">{(x y z) &lt;+ (u v w) &lt;+ (a b
          c)&nbsp; &lt;+ (values 2 4 5)}<br>
          2<br>
          4<br>
          5<br>
          (list x y z u v w a b c)<br>
          '(2 4 5 2 4 5 2 4 5)<br>
        </p>
        <p style="margin-left: 40px;">We can also assign multiple values
          on
          the fly:<br>
        </p>
        <p style="margin-left: 40px;">(declare x y z)<br>
          {(x y z) &lt;v (values 2 4 5)}<br>
          2<br>
          4<br>
          5<br>
          (list x y z)<br>
          '(2 4 5)<br>
          (declare u v w)<br>
          {(x y z) &lt;v (u v w) &lt;v (values 2 4 5)}<br>
          2<br>
          4<br>
          5<br>
          (list x y z u v w)<br>
          '(2 4 5 2 4 5)<br>
        </p>
        <p style="margin-left: 40px;"><br>
        </p>
        <p>Here is an example of the previous features about a <a
href="https://en.wikipedia.org/wiki/Subset_sum_problem#Pseudo-polynomial_time_dynamic_programming_solutions"
            target="_blank">dynamic solution of the subset sum problem</a>:
        </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span><span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"SRFI-105.rkt"</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">Scheme-PLUS-for-Racket/Scheme+</span><span class="p">)</span>


<span class="p">(</span><span class="nf">declare</span> <span class="nv">L-init</span> <span class="nv">t-init</span> <span class="nv">ls</span> <span class="nv">dyna</span> <span class="nv">cpt</span><span class="p">)</span>

<span class="p">{</span><span class="nv">L-init</span> <span class="nv">&lt;-</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">24</span> <span class="mi">45</span> <span class="mi">64</span> <span class="mi">197</span> <span class="mi">256</span> <span class="mi">275</span> <span class="mi">323</span> <span class="mi">540</span> <span class="mi">723</span> <span class="mi">889</span> <span class="mi">915</span> <span class="mi">1040</span> <span class="mi">1041</span> <span class="mi">1093</span> <span class="mi">1099</span> <span class="mi">1111</span> <span class="mi">1284</span> <span class="mi">1344</span> <span class="mi">1520</span> <span class="mi">2027</span> <span class="mi">2500</span> <span class="mi">2734</span> <span class="mi">3000</span> <span class="mi">3267</span> <span class="mi">3610</span> <span class="mi">4285</span> <span class="mi">5027</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">t-init</span> <span class="nv">&lt;-</span> <span class="mi">35267</span><span class="p">}</span>
<span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L-init</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">dyna</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mi">0</span> <span class="p">{</span><span class="nv">ls</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="nv">t-init</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span><span class="p">}</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">b</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">{</span><span class="nv">cpt</span> <span class="nv">&lt;-</span> <span class="mi">0</span><span class="p">}</span>


<span class="p">(</span><span class="nf">def</span> <span class="p">(</span><span class="nf">subset-sum-dynamic</span> <span class="nv">L</span> <span class="nv">t</span><span class="p">)</span>

  <span class="p">(</span><span class="nf">declare</span> <span class="nv">ls</span> <span class="nv">dyn</span> <span class="nv">c</span> <span class="nv">R</span> <span class="nv">s</span><span class="p">)</span> <span class="c1">;; declare multiple variables</span>

  <span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;-</span> <span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span><span class="p">}</span> <span class="c1">;; dyna is a toplevel defined array</span>

  <span class="c1">;; dyna[ls t] means : 0: unknown solution, 1: solution found, 2: no solution</span>

  <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="c1">;; IF or WHEN : it is the same thing here (only one statement)</span>
      <span class="p">(</span><span class="nf">return</span> <span class="p">(</span><span class="nf">one?</span> <span class="nv">dyn</span><span class="p">)))</span>

  <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">null?</span> <span class="nv">L</span><span class="p">)</span>
    <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">2</span><span class="p">}</span>
    <span class="p">(</span><span class="nf">return</span> <span class="no">#f</span><span class="p">))</span>

  <span class="p">{</span><span class="nv">c</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>

  <span class="p">(</span><span class="nf">when</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">=</span> <span class="nv">t</span><span class="p">}</span>  <span class="c1">;; c is the solution</span>
    <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">(</span><span class="nf">return</span> <span class="no">#t</span><span class="p">))</span>

  <span class="p">{</span><span class="nv">R</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; continue searching a solution in the rest</span>

  <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">&gt;</span> <span class="nv">t</span><span class="p">}</span>  <span class="c1">;; c is to big to be a solution</span>
    <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">subset-sum-dynamic</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}</span>
    <span class="c1">;; c is part of the solution or c is not part of solution</span>
    <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="p">(</span><span class="nf">subset-sum-dynamic</span> <span class="nv">R</span> <span class="p">{</span><span class="nv">t</span> <span class="nv">-</span> <span class="nv">c</span><span class="p">}</span><span class="p">)</span> <span class="nv">or</span> <span class="p">(</span><span class="nf">subset-sum-dynamic</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}}</span><span class="p">)</span>

  <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
  <span class="nv">s</span><span class="p">)</span> <span class="c1">;; return boolean value</span>


<span class="o"></span></code></pre>
        </figure>
        <pre>(subset-sum-dynamic  L-init t-init)
#t
<br>
</pre>
        <br>
        <br>
        <p> Warnings about code highlighting tag due to bugs in Github
          Markdown system:<br>
          <br>
          -if you read this page on github.com the code examples display
          encapsuled between tags 'highlight scheme' and 'endhighlight'
          composed also with {} and % characters.<br>
          <br>
          -if you read this page on github.io the code examples display
          starting with 3 backquotes char , the tag 'scheme' and ending
          again with 3 backquotes char. The curly brackets {} display in
          a rectangular with red background because the Github Jekill
          rouge theme (unfortunately the ony one available) does not
          understand the infix notation of Scheme.This is,of course, not
          what i expected but i can not find any issue to this problem.<br>
          <br>
          Those weirds Markdown and tags should not be displayed and are
          not part of Scheme+ examples. <a
href="https://damien-mattei.github.io/Scheme-PLUS-for-Racket/Scheme+.html"
            target="_blank">for a better view click here (or do not care
            of highlighting tag and triple backquotes when code is
            displayed!)</a><br>
        </p>
        <br>
        <br>
        <p>Another example with DrRacket Scheme in the REPL (Read Eval
          Print Loop):</p>
        <p> </p>
        <img moz-do-not-send="true"
          src="Scheme+io_fichiers/racket-example.png" alt="example
          Racket scheme+ complex exponential" width="1100" height="722"><br>
        <p> </p>
        <br>
        <p>Hash Tables support :</p>
        <pre>(require Scheme-PLUS-for-Racket/Scheme+)

(require srfi/69)   ;; support for SRFI 69 <meta http-equiv="content-type" content="text/html; charset=UTF-8">Basic hash tables

{my-hash-tbl &lt;+ (make-hash-table)} ;; add an object in the current environment, here a hash table
(hash-table? my-hash-tbl)
#t
<br>{my-hash-tbl["three"] &lt;- 3}
3<br><br>{my-hash-tbl["three"]}
3

</pre>
        <p>for the rest read below and the documentation.</p>
        <br>
        <h2>2.<u>Download Scheme+:</u></h2>
        <p>The source code of the <b>Scheme+ module</b> for <a
            href="https://racket-lang.org/" target="_blank">Racket
            implementation of Scheme</a> can be retrieved here: </p>
        <p><br>
        </p>
        <h3 style=" text-align: center;">&gt;&gt;&gt;&nbsp;&nbsp; <a
href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/zipball/main"
            target="_blank">Download Scheme+ as .zip</a>&nbsp;&nbsp;
          &lt;&lt;&lt;<br>
        </h3>
        <p><br>
        </p>
        <h3 style=" text-align: center;">&gt;&gt;&gt;&nbsp;&nbsp; <a
href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/tarball/main"
            target="_blank">Download Scheme+ as .tar.gz</a>&nbsp;&nbsp;
          &lt;&lt;&lt;<br>
        </h3>
        <p><br>
        </p>
        <h3 style=" text-align: center;">&gt;&gt;&gt;&nbsp;&nbsp; <a
            href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket"
            target="_blank">https://github.com/damien-mattei/Scheme-PLUS-for-Racket

            --&gt; Code --&gt; Download ZIP</a>&nbsp;&nbsp; &lt;&lt;&lt;<br>
        </h3>
        <p><br>
        </p>
        <p>Including : <br>
        </p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">An implementation of the SRFI-105
          "Curly Infix" with a REPL (Read Eval Print Loop) for Racket.
          (file SRFI-105.rkt)<br>
        </p>
        <p style="margin-left: 40px;">The enhanced set of LET special
          forms
          in the file let.scm.</p>
        <div style="margin-left: 40px;"> </div>
        <p style="margin-left: 40px;">Many of the examples of this web
          page
          are in the source file SssDyna.scm.</p>
        <h2><br>
        </h2>
        <h2>3<u>.Requirements:</u><br>
        </h2>
        <p>Scheme+ needs a Scheme interpreter and will be adapted and
          released for many Scheme (Guile,Racket,...), download Racket
          Scheme:<br>
        </p>
        <a href="https://racket-lang.org/" target="_blank"><img
            moz-do-not-send="true"
            src="Scheme+io_fichiers/logo-and-text-1-2.png" title="Racket
            Scheme" alt="Racket Scheme web site" width="396" border="0"
            height="120"></a><br>
        <br>
        <p>It has been developed with Racket v8.2 on <b>Mac</b><font
            color="#9999ff"><b> </b><b>OS</b></font> and Racket v7.7
          under <b>Linux</b>.<br>
          <br>
          <br>
          <br>
        </p>
        <h2>4.<u>Author and license:</u></h2>
        <p><b>Damien Mattei </b>; <b>Scheme+</b> : Copyright 2021-2022
          <b>Damien Mattei </b>under <a
            href="https://www.gnu.org/licenses/gpl-3.0.txt"
            target="_blank">GNU GENERAL PUBLIC LICENSE Version 3</a></p>
        <p>Nice - France (commune de Carros) </p>
        <p> contact : firstname Dot lastname At Google Mail</p>
        <p>Guagno - Island of Corsica </p>
        <br>
        <p>To subit an issue, a bug or something else related with the
          Scheme+ code use the <a
            href="https://github.com/damien-mattei/Scheme-PLUS-for-Racket/issues"
            target="_blank" moz-do-not-send="true">Github issues system</a>.<br>
        </p>
        <p><br>
        </p>
        <h2>5.<u>Installation:</u></h2>
        <p><br>
          The easiest way to install Scheme+ for Racket is via the
          official
          packet manager of Racket&nbsp; : <b>File -&gt; Packet Manager</b>
          and go to tab '<b>Available from catalog</b>' and filter for '<b>Scheme+</b>'
          key word.<br>
        </p>
        <p>Other way is also from Packet manager to install the
          dowloaded
          package via th tab '<b>Do what i mean' -&gt; Browse -&gt;
            Directory</b> and select the directory downloaded and
          uncompressed in the section 2 of this page.<br>
        </p>
        <p>Anyway you can find the Scheme+ for Racket package here: <a
href="https://pkgs.racket-lang.org/package/Scheme-PLUS-for-Racket"
            title="Scheme+ package for Racket" target="_blank">https://pkgs.racket-lang.org/package/Scheme-PLUS-for-Racket</a>
          .<br>
        </p>
        You also need the <b>SRFI-105 Curly Infix language</b> for
        Racket
        and its REPL (Read Eval Print Loop) that will allow you to use
        infix
        notation and Scheme+.<br>
        <br>
        This is <b>mandatory</b>.<br>
        <br>
        You can find the <b>SRFI-105.rkt</b> file in the downloaded
        package
        of Scheme+ (in the subdirectory <b>SRFI</b>)<br>
        <br>
        <h2><u>6. Idea and rationale:</u></h2>
        <p>The core language of <a
            href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29"
            target="_blank">Scheme</a> and <a
            href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29"
            target="_blank">Lisp</a> are based on syntaxic form that
          date back from '50 for Lisp and '70 for Scheme. Syntactic
          forms such as the set of LET,LET*,LETREC,... have since long
          ago been replaced in many other languages
          (C/C++,Java,Fortran,Pascal,Javascript,BASIC (the LET keyword
          can be ommited in Applesoft Basic),by simple assignment
          operator that frees the syntax and allow saving indentation
          space, number of parenthesis, readability of code.</p>
        <p>The main idea of this project is to improve Scheme and Lisp
          like languages with syntaxic features,such as easy assignment
          for many object types (numbers,strings,vectors,arrays,etc),and
          also allowing an immediate 'return' mechanism to escape from
          procedure when result is known and others features that exist
          in others languages
          (Python,Java,C/C++,Pascal,BASIC,Javascript). Some new features
          can be and are better used with infix notations (<a
            href="https://srfi.schemers.org/srfi-105/srfi-105.html"
            target="_blank">SRFI 105</a> known as "Curly Infix"),so for
          some syntactic expressions infix will be promoted (but not
          mandatory). </p>
        <p>A few new feature (see below) allow a great change in syntax
          and readability of Scheme programs. Less parenthesis are
          used,less indentation and it allows an enhanced programming
          style that modernize Scheme but also keep it 100% compatible
          with the original language.</p>
        <p>Also vectors and arrays in Scheme are painfully accessed and
          modified by vector-ref and vector-set! , Scheme+ use a
          simplier syntax again with the &lt;- operator and the []
          syntax.</p>
        <p>This intuitive notation works also with Hash Tables.</p>
        <p>Scheme+ will remove the need for the classic LET set of
          special form, no more need of <strike>LET,LET*,LETREC,LET-VALUES</strike>,...
          and will use an unique infix (or not) assignment operator :
          &lt;-. (also LET are enhanced - the project starts historically by
          improving and simplifying LET, i simplified it so much that i
          remove it now! - in other versions such as let&lt;-arrow
          requiring less brackets, even if their use is useless and no
          more promoted, see extra features part)</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2><u>7. Features:</u></h2>
        <p>The list of new features is subject to change and will grow
          by time, this version allows:</p>
        <ul>
          <li>use of infix SRFI 105 "Curly Infix" for some syntax forms</li>
          <li>Assignment operator : <b>&lt;-</b> (can be used in infix
            syntax and from left to right and right to left)</li>
          <li>Square Bracket operator<b> []</b> working with Scheme <b>Vectors,

              Arrays,Multidimentional Arrays,Hash Tables</b>,<b>Strings</b>...</li>
          <li>combination of Assignment operator &lt;- with [] operator
            for Vectors,Arrays,....</li>
          <li>RETURN : <b>return</b> keyword used in any procedure to
            return from procedure and return a value.</li>
          <li>declaration of variables</li>
          <li>declaration and assignment of variables with an infix
            operator.</li>
          <li>conditionals and execution of code in a new form : condx</li>
          <li>extra feature: new set of LET special forms,even if their
            use is completely discouraged in favor of assignment
            operator combined with declarative form (see declare).</li>
        </ul>
        <h2><br>
        </h2>
        <p><br>
        </p>
        <h2><u>8. First Examples:</u></h2>
        <h3 style=" margin-left: 40px;">The <a
            href="https://en.wikipedia.org/wiki/Fibonacci_number"
            target="_blank">Fibonacci sequence</a>:</h3>
        <p style="margin-left: 40px;">This example is written in Scheme
          with and without infix notation just to allow the reader to be
          familiar with "curly infix" notation which is not part of
          Scheme+ but used by it:</p>
        <p style="margin-left: 40px;">Here is the definition in classic
          prefix Scheme:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fibonacci</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nv">n</span>
    <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">fibonacci</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)))))</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="margin-left: 40px;">And here is a definition using
          "Curly Infix" SRFI 105:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">&lt;</span> <span class="mi">2</span><span class="p">}</span>
      <span class="nv">n</span>
      <span class="p">{</span><span class="p">(</span><span class="nf">fib</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span> <span class="nv">+</span> <span class="p">(</span><span class="nf">fib</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">2</span><span class="p">}</span><span class="p">)</span><span class="p">}</span> <span class="p">))</span>


<span class="o"></span></code></pre>
        </figure>
        <p> </p>
        <br>
        <p>note that the last expression of fib: <b>{(fib {n - 1}) +
            (fib {n - 2})} </b>could also be expressed in curly infix
          Scheme like that :<b> {fib({n - 1}) + fib({n - 2})}</b> or
          even like that: <b>{fib{n - 1} + fib{n - 2}} </b>but i will
          not use them, preferring to use infix only where mathematical
          calculus are coded and for comparaison tests in conditionals.</p>
        <p>Fibonacci is time consuming,even fib(47) can takes minutes to
          compute. We will write a faster dynamic version that memorize
          the results computed more than one time.</p>
        <p>Here is a solution in classic Scheme:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define</span> <span class="nv">size0</span> <span class="mi">10000</span><span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">memo0</span> <span class="p">(</span><span class="nb">make-vector</span> <span class="nv">size0</span> <span class="mi">0</span><span class="p">))</span><span class="nv">return</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fibdyna0</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">((</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">((</span><span class="nb">not</span> <span class="p">(</span><span class="nb">zero?</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="nv">memo0</span> <span class="nv">n</span><span class="p">)))</span> <span class="p">(</span><span class="nb">vector-ref</span> <span class="nv">memo0</span> <span class="nv">n</span><span class="p">))</span>
	<span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">fibn</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nf">fibdyna0</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">fibdyna0</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)))))</span>
		<span class="p">(</span><span class="nb">vector-set!</span> <span class="nv">memo0</span> <span class="nv">n</span> <span class="nv">fibn</span><span class="p">)</span>
		<span class="nv">fibn</span><span class="p">))))</span>


<span class="o"></span></code></pre>
        </figure>
        <p> </p>
        <br>
        <p>In the example above we can notice that the array access and
          modification is not easy to read and in the <b>else</b> block
          i have to use a <b>let</b> special form to create a local
          variable to return the value computed and already stored in
          array,even if i have not used a local variable i then must
          have to access the result in array to return it...</p>
        <p>Scheme+ allow to write code more readable and simpler than
          normal Scheme.</p>
        <p>Prior to use <b>Scheme+</b> for DrRacket Scheme, you must
          add a
          <b>#lang reader "SRFI-105.rkt" </b>directive in the first
          line of
          your program and the <b>module </b>must be loaded,this is
          done
          by inserting the statement <b>(require
            Scheme-PLUS-for-Racket/Scheme+)</b> in your program, however
          another method can be to 'require' the file : <b>(require
            "Scheme+.rkt") </b>if you have downloaded the source code.</p>
        <p>Below is the version of the above code written in Scheme+ :</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>
<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"SRFI-105.rkt"</span>
<span class="p">(</span><span class="nf">require</span> <span class="nv">Scheme-PLUS-for-Racket/Scheme+</span><span class="p">)</span>

<span class="p">{</span><span class="nv">size</span> <span class="nv">&lt;+</span> <span class="mi">10000</span><span class="p">}</span>
<span class="p">{</span><span class="nv">memo</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nb">make-vector</span> <span class="nv">size</span> <span class="mi">0</span><span class="p">)</span><span class="p">}</span> 

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fibdyna</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">cond</span> <span class="p">(</span><span class="p">{</span><span class="nv">n</span> <span class="nv">&lt;</span> <span class="mi">2</span><span class="p">}</span> <span class="nv">n</span><span class="p">)</span>
         <span class="p">(</span><span class="p">{</span><span class="nv">memo</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="nv">memo</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span><span class="p">}</span><span class="p">)</span>
         <span class="p">(</span><span class="k">else</span> <span class="p">{</span><span class="nv">memo</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="p">(</span><span class="nf">fibdyna</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span> <span class="nv">+</span> <span class="p">(</span><span class="nf">fibdyna</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">2</span><span class="p">}</span><span class="p">)</span><span class="p">}}</span><span class="p">)</span> <span class="p">))</span>


<span class="o"></span></code></pre>
        </figure>
        <p></p>
        <p> </p>
        <br>
        <p>The reader can notice the introduction of one new assignment
          operator <b>&lt;-</b> and also <b>&lt;+</b>, the latter
          being simply an infix <b>define</b> of Scheme. The important
          point of the new assignment operator <b>&lt;-</b> of <b>Scheme+</b>
          is that it will work like the classic <b>set! </b>of Scheme
          on variables but also will work on more <b>complex object
            such as element of vectors,multidimensional arrays (as
            defined in SRFIs),... and much more in the next versions of
            Scheme+</b>. (we will see another more complex example with
          multidimentional array later)</p>
        <p>So <b>{x &lt;- 7} </b>simply assign 7 to the variable x but
          <b>{m[3] &lt;- 7}</b> will store 7 in the array <b>m </b>at
          the position indexed by 3. Access an element of array is also
          simpler in Scheme+ than in Scheme: <b>{m[3]}</b>. And this
          syntax is 100% compatible with Scheme, you can mix both the
          syntaxes if you want. This syntax is also more natural and
          readable and much like the mathematical notation, it is also a
          syntax used for arrays in other languages such as
          C/C++,Python,Java,Pascal,Javascript...</p>
        <p>Also you will notice&nbsp; that the main computation in the <b>else</b>
          block is now shorter and it is partly due to the fact that the
          assignment operator <b>&lt;- </b>return not NIL but the
          affected <b>value</b> making it available for other calculus
          or as a final result value.</p>
        <p>Here is now the same solution in a declarative form, in the
          part&nbsp; called "History of project" i explain why there
          exist two solutions. </p>
        <p>Instead of declare and assign the variables with the <b>define</b>
          nested in the <b>macro &lt;+ </b>we also can <b>declare</b>
          them and assign the variables later with the universal <b>&lt;-</b>
          operator:</p>
        <h2><br>
        </h2>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>
<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"SRFI-105.rkt"</span>
<span class="p">(</span><span class="nf">require</span> <span class="nv">Scheme-PLUS-for-Racket/Scheme+</span><span class="p">)</span>

<span class="p">(</span><span class="nf">declare</span> <span class="nv">size1</span> <span class="nv">memo1</span><span class="p">)</span>

<span class="p">{</span><span class="nv">size1</span> <span class="nv">&lt;-</span> <span class="mi">10000</span><span class="p">}</span>
<span class="p">{</span><span class="nv">memo1</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">make-vector</span> <span class="nv">size</span> <span class="mi">0</span><span class="p">)</span><span class="p">}</span> 
  
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fibdyna1</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond</span> <span class="p">(</span><span class="p">{</span><span class="nv">n</span> <span class="nv">&lt;</span> <span class="mi">2</span><span class="p">}</span> <span class="nv">n</span><span class="p">)</span>
	<span class="p">(</span><span class="p">{</span><span class="nv">memo1</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="nv">memo1</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span><span class="p">}</span><span class="p">)</span>
	<span class="p">(</span><span class="k">else</span> <span class="p">{</span><span class="nv">memo1</span><span class="p">[</span><span class="nf">n</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="p">(</span><span class="nf">fibdyna1</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span> <span class="nv">+</span> <span class="p">(</span><span class="nf">fibdyna1</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">2</span><span class="p">}</span><span class="p">)</span><span class="p">}}</span><span class="p">)</span> <span class="p">))</span>


<span class="o"></span></code></pre>
        </figure>
        <h2><br>
        </h2>
        <h2><u>9.Short documentation</u></h2>
        <p>Square bracket operator <b>[] </b>is used for
          vectors,arrays,hash tables,etc.</p>
        <p>example: <b>{T[k]} </b>return value of vector or array T
          indexed by k.</p>
        <p><br>
        </p>
        <p>Assignment operator <b>&lt;- </b>can be used only on
          existing single variables or vector,arrays,etc . Note that
          vector and arrays must be defined the usual way they are in
          Scheme. The operator &lt;- works also with multidimensional
          arrays.</p>
        <p>examples : </p>
        <ol>
          <li><b>{x &lt;- 7} </b></li>
          <li><b>{x &lt;- y} </b></li>
          <li><b>{m[3] &lt;- 7}</b></li>
          <li><b>{T</b><b>[k] &lt;- x}</b></li>
          <li><b>{T</b><b>[k] &lt;- </b><b><b>T</b><b>[{k + 1}]</b>}</b></li>
          <li><b><b>{</b>T</b><b>[m n] &lt;- </b><b><b>T</b><b>[m {n +
                1}]</b>}</b></li>
          <li><b>{my-hash-tbl["three"] &lt;- 3}</b></li>
        </ol>
        <p><br>
        </p>
        <p>Definition and assignment of variables is made with the <b>&lt;+</b>
          operator but can also be done with the classic Scheme <b>define</b>.</p>
        <p>example: {size &lt;+ 1000}</p>
        <p><br>
        </p>
        <p>Declaration of variable can also be used to <b>declare</b>
          one or many variables. (for explanation why there exist still
          <b>&lt;+</b> and <b>declare</b> and not only <b>&lt;-</b>
          read the part history of project)</p>
        <p>example: <b>(declare x y z t)</b></p>
        <p> </p>
        <br>
        <p><br>
        </p>
        <br>
        <p><u>How to load a Scheme+ program:</u></p>
        <p>Scheme+ programs are loaded this way in Racket and must have
          a <b>(provide (all-defined-out))</b> to export all bindings:</p>
        <pre>(require "logiki+.rkt")<br><br>(infix-symb-min-dnf '{ {(not a) and (not b) and (not c) and (not d)} or {(not a) and (not b) and (not c) and d} or {(not a) and (not b) and c and (not d)} or {(not a) and b and (not c) and d} or {(not a) and b and c and (not d)} or {(not a) and b and c and d} or {a and (not b) and (not c) and (not d)} or {a and (not b) and (not c) and d} or {a and (not b) and c and (not d)} or {c and (not d)} } )
disj-norm-form = (or (and c (not d)) (and (not a) (not b) (not c) (not d)) (and (not a) (not b) (not c) d) (and (not a) b (not c) d) (and (not a) b c d) (and a (not b) (not c) (not d)) (and a (not b) (not c) d))
<br>'((¬b ∧ ¬c) ∨ (c ∧ ¬d) ∨ (¬a ∧ b ∧ d))</pre>
        <p>We can use a convention to name the Scheme+ programs and
          function with a + at end, keeping the .scm extension unchanged
          for compatibility.<br>
        </p>
        <p><br>
        </p>
        <h2>10<u>.Advanced examples:</u><br>
        </h2>
        <p>Here is another example, from the <a
href="https://en.wikipedia.org/wiki/Subset_sum_problem#Pseudo-polynomial_time_dynamic_programming_solution"
            target="_blank">Subset Sum Problem</a> that show the use of
          <b>&lt;+</b> and <b>&lt;-</b> (due to the impossibility to
          have easily a single operator :-( ) :</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"../SRFI/SRFI-105.rkt"</span>

<span class="p">(</span><span class="nf">require</span> <span class="s">"../Scheme+.rkt"</span><span class="p">)</span>
<span class="c1">;;(require Scheme-PLUS-for-Racket/Scheme+)</span>

<span class="p">{</span><span class="nv">L-init</span> <span class="nv">&lt;+</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">24</span> <span class="mi">45</span> <span class="mi">64</span> <span class="mi">197</span> <span class="mi">256</span> <span class="mi">275</span> <span class="mi">323</span> <span class="mi">540</span> <span class="mi">723</span> <span class="mi">889</span> <span class="mi">915</span> <span class="mi">1040</span> <span class="mi">1041</span> <span class="mi">1093</span> <span class="mi">1099</span> <span class="mi">1111</span> <span class="mi">1284</span> <span class="mi">1344</span> <span class="mi">1520</span> <span class="mi">2027</span> <span class="mi">2500</span> <span class="mi">2734</span> <span class="mi">3000</span> <span class="mi">3267</span> <span class="mi">3610</span> <span class="mi">4285</span> <span class="mi">5027</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">t-init</span> <span class="nv">&lt;+</span> <span class="mi">35267</span><span class="p">}</span>
<span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L-init</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">dyna</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mi">0</span> <span class="p">{</span><span class="nv">ls</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="nv">t-init</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span><span class="p">}</span>

<span class="p">{</span><span class="nv">cpt</span> <span class="nv">&lt;+</span> <span class="mi">0</span><span class="p">}</span> <span class="c1">;; define cpt to 0</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">subset-sum-guile</span> <span class="nv">L</span> <span class="nv">t</span><span class="p">)</span>

  <span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;+</span> <span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span><span class="p">}</span>

  <span class="p">{</span><span class="nv">cpt</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="nv">cpt</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}}</span> <span class="c1">;; cpt has been already defined at toplevel</span>
  
  <span class="c1">;; dyna[ls t] means 0: unknown solution, 1: solution found, 2: no solution</span>
  
  <span class="p">(</span><span class="nf">condx</span> <span class="p">[</span><span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="p">(</span><span class="nf">one?</span> <span class="nv">dyn</span><span class="p">)]</span>
	 <span class="p">[(</span><span class="nb">null?</span> <span class="nv">L</span><span class="p">)</span> <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">2</span><span class="p">}</span>  <span class="no">#f</span><span class="p">]</span> <span class="c1">;; return #f</span>
	 
	 <span class="p">[</span><span class="nf">exec</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span><span class="p">]</span>	 
	 <span class="c1">;; c is the solution</span>
	 <span class="p">[</span><span class="p">{</span><span class="nv">c</span> <span class="nv">=</span> <span class="nv">t</span><span class="p">}</span> <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">1</span><span class="p">}</span>  <span class="no">#t</span><span class="p">]</span>  <span class="c1">;; return #t</span>
	 
	 <span class="p">[</span><span class="nf">exec</span> <span class="p">{</span><span class="nv">R</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span><span class="p">]</span>	 
	 <span class="c1">;; continue searching a solution in the rest</span>
	 <span class="p">[</span><span class="p">{</span><span class="nv">c</span> <span class="nv">&gt;</span> <span class="nv">t</span><span class="p">}</span> <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">subset-sum-guile</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}</span>
	          <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
		  <span class="nv">s</span><span class="p">]</span> <span class="c1">;; return boolean value</span>
			
	 <span class="c1">;; else : c &lt; t at this point</span>
	 <span class="c1">;; c is part of a solution OR not part of a solution</span>
	 <span class="p">[</span><span class="k">else</span> <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;+</span> <span class="p">{</span><span class="p">(</span><span class="nf">subset-sum-guile</span> <span class="nv">R</span> <span class="p">{</span><span class="nv">t</span> <span class="nv">-</span> <span class="nv">c</span><span class="p">}</span><span class="p">)</span> <span class="nv">or</span> <span class="p">(</span><span class="nf">subset-sum-guile</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}}</span>
	       <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
	       <span class="nv">s</span><span class="p">]))</span> <span class="c1">;; return boolean value</span>


<span class="o"></span></code></pre>
        </figure>
        <p> </p>
        <br>
        <p><b>(subset-sum-guile&nbsp; L-init t-init)</b></p>
        <p><b>#t</b><br>
          <br>
        </p>
        <p style="text-align: center;">note: in the example above condx
          is a macro that allow execution of arbitrary code between
          conditionals clauses,general syntax is:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">condx</span> <span class="p">[</span><span class="nf">condition</span> <span class="nv">statements</span> <span class="o">...</span><span class="p">]</span>

            <span class="p">[</span><span class="nf">exec</span> <span class="nv">statements</span> <span class="o">...</span> <span class="p">]</span>

            <span class="o">...</span>

            <span class="p">[</span><span class="k">else</span> <span class="nv">statements</span> <span class="o">...</span><span class="p">])</span>


<span class="o"></span></code></pre>
        </figure>
        <div style="margin-left: 40px;"> </div>
        <p style="text-align: center;"><br>
        </p>
        <p style="text-align: left;">In classic Scheme the code would be
          like that which is longer than in Scheme+:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define</span> <span class="nv">cpt</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ssigma-proto</span> <span class="nv">L</span> <span class="nv">t</span><span class="p">)</span>

  <span class="p">(</span><span class="k">set!</span> <span class="nv">cpt</span> <span class="p">{</span><span class="nv">cpt</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span>
 
  <span class="p">(</span><span class="k">define</span> <span class="nv">ls</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L</span><span class="p">))</span>
  <span class="p">(</span><span class="k">define</span> <span class="nv">dyn</span> <span class="p">(</span><span class="nf">array-ref</span> <span class="nv">dyna</span> <span class="nv">ls</span> <span class="nv">t</span><span class="p">))</span>
    
  <span class="c1">;; dyna[ls][t] means 0: unknown solution, 1: solution found, 2: no solution</span>

  <span class="p">(</span><span class="k">cond</span> <span class="p">[(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">zero?</span> <span class="nv">dyn</span><span class="p">))</span> <span class="p">(</span><span class="nf">one?</span> <span class="nv">dyn</span><span class="p">)]</span>
	<span class="p">[(</span><span class="nb">null?</span> <span class="nv">L</span><span class="p">)</span> <span class="p">(</span><span class="nf">array-set!</span> <span class="nv">dyna</span> <span class="mi">2</span> <span class="nv">ls</span> <span class="nv">t</span><span class="p">)</span> <span class="no">#f</span><span class="p">]</span> <span class="c1">;; return #f</span>
	
	<span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="k">let</span> <span class="p">[(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">L</span><span class="p">))]</span>
		
		<span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">=</span> <span class="nv">t</span><span class="p">}</span> <span class="c1">;; c is the solution</span>
		      
		    <span class="p">(</span><span class="k">begin</span>
		      <span class="p">(</span><span class="nf">array-set!</span> <span class="nv">dyna</span> <span class="mi">1</span> <span class="nv">ls</span> <span class="nv">t</span><span class="p">)</span>
		      <span class="no">#t</span><span class="p">)</span>  <span class="c1">;; return #t</span>

		    <span class="c1">;; else</span>
		    <span class="p">(</span><span class="k">let</span> <span class="p">[(</span><span class="nf">R</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">L</span><span class="p">))]</span>
		      
		      <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">&gt;</span> <span class="nv">t</span><span class="p">}</span>   <span class="c1">;; continue searching a solution in the rest</span>
			    
			  <span class="p">(</span><span class="k">let</span> <span class="p">[(</span><span class="nf">s</span> <span class="p">(</span><span class="nf">ssigma-proto</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">))]</span>
			    <span class="p">(</span><span class="nf">array-set!</span> <span class="nv">dyna</span>
					<span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span>
					<span class="nv">ls</span> <span class="nv">t</span><span class="p">)</span>
			      
			    <span class="nv">s</span><span class="p">)</span> <span class="c1">;; return s</span>
			
			  <span class="c1">;; else</span>
			  <span class="c1">;; c &lt; t at this point</span>
			  <span class="c1">;; c is part of the solution or his approximation</span>
			  <span class="c1">;; or c is not part of solution</span>
			  <span class="p">(</span><span class="k">let</span> <span class="p">[(</span><span class="nf">s</span> <span class="p">{</span><span class="p">(</span><span class="nf">ssigma-proto</span> <span class="nv">R</span> <span class="p">{</span><span class="nv">t</span> <span class="nv">-</span> <span class="nv">c</span><span class="p">}</span><span class="p">)</span> <span class="nv">or</span> <span class="p">(</span><span class="nf">ssigma-proto</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}</span><span class="p">)]</span>
			    <span class="p">(</span><span class="nf">array-set!</span> <span class="nv">dyna</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span>
					<span class="nv">ls</span> <span class="nv">t</span><span class="p">)</span>
			    <span class="nv">s</span><span class="p">)))))</span>
	      <span class="p">]</span> <span class="p">))</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="text-align: left;"> <br>
        </p>
        <p style="text-align: left;"><br>
        </p>
        <p style="text-align: left;">If you want to use a single
          assignment operator <b>&lt;-</b> it is possible using a
          declarative programming style with the <b>declare </b>macro:</p>
        <p> </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"../SRFI/SRFI-105.rkt"</span>
<span class="c1">;;(require "../Scheme+.rkt")</span>
<span class="p">(</span><span class="nf">require</span> <span class="nv">Scheme-PLUS-for-Racket/Scheme+</span><span class="p">)</span>


<span class="p">(</span><span class="nf">declare</span> <span class="nv">L-init</span> <span class="nv">t-init</span> <span class="nv">ls</span> <span class="nv">dyna</span> <span class="nv">cpt</span><span class="p">)</span>

<span class="p">{</span><span class="nv">L-init</span> <span class="nv">&lt;-</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">24</span> <span class="mi">45</span> <span class="mi">64</span> <span class="mi">197</span> <span class="mi">256</span> <span class="mi">275</span> <span class="mi">323</span> <span class="mi">540</span> <span class="mi">723</span> <span class="mi">889</span> <span class="mi">915</span> <span class="mi">1040</span> <span class="mi">1041</span> <span class="mi">1093</span> <span class="mi">1099</span> <span class="mi">1111</span> <span class="mi">1284</span> <span class="mi">1344</span> <span class="mi">1520</span> <span class="mi">2027</span> <span class="mi">2500</span> <span class="mi">2734</span> <span class="mi">3000</span> <span class="mi">3267</span> <span class="mi">3610</span> <span class="mi">4285</span> <span class="mi">5027</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">t-init</span> <span class="nv">&lt;-</span> <span class="mi">35267</span><span class="p">}</span>
<span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L-init</span><span class="p">)</span><span class="p">}</span>
<span class="p">{</span><span class="nv">dyna</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">make-array</span> <span class="mi">0</span> <span class="p">{</span><span class="nv">ls</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="nv">t-init</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span><span class="p">}</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">b</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">{</span><span class="nv">cpt</span> <span class="nv">&lt;-</span> <span class="mi">0</span><span class="p">}</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">subset-sum-guile-dec</span> <span class="nv">L</span> <span class="nv">t</span><span class="p">)</span>

  <span class="p">(</span><span class="nf">declare</span> <span class="nv">ls</span> <span class="nv">dyn</span> <span class="nv">c</span> <span class="nv">R</span> <span class="nv">s</span><span class="p">)</span>
  
  <span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;-</span> <span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span><span class="p">}</span>

  <span class="p">{</span><span class="nv">cpt</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="nv">cpt</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}}</span> <span class="c1">;; cpt has been already defined at toplevel</span>
  
  <span class="c1">;; dyna[ls t] means 0: unknown solution, 1: solution found, 2: no solution</span>
  
  <span class="p">(</span><span class="nf">condx</span> <span class="p">[</span><span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="p">(</span><span class="nf">one?</span> <span class="nv">dyn</span><span class="p">)]</span>
	 <span class="p">[(</span><span class="nb">null?</span> <span class="nv">L</span><span class="p">)</span> <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">2</span><span class="p">}</span>  <span class="no">#f</span><span class="p">]</span> <span class="c1">;; return #f</span>
	 
	 <span class="p">[</span><span class="nf">exec</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span><span class="p">]</span>	 
	 <span class="c1">;; c is the solution</span>
	 <span class="p">[</span><span class="p">{</span><span class="nv">c</span> <span class="nv">=</span> <span class="nv">t</span><span class="p">}</span> <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">1</span><span class="p">}</span>  <span class="no">#t</span><span class="p">]</span>  <span class="c1">;; return #t</span>
	 
	 <span class="p">[</span><span class="nf">exec</span> <span class="p">{</span><span class="nv">R</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span><span class="p">]</span>	 
	 <span class="c1">;; continue searching a solution in the rest</span>
	 <span class="p">[</span><span class="p">{</span><span class="nv">c</span> <span class="nv">&gt;</span> <span class="nv">t</span><span class="p">}</span> <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">subset-sum-guile-dec</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}</span>
	          <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
		  <span class="nv">s</span><span class="p">]</span> <span class="c1">;; return boolean value</span>
			
	 <span class="c1">;; else : c &lt; t at this point</span>
	 <span class="c1">;; c is part of a solution OR not part of a solution</span>
	 <span class="p">[</span><span class="k">else</span> <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="p">(</span><span class="nf">subset-sum-guile-dec</span> <span class="nv">R</span> <span class="p">{</span><span class="nv">t</span> <span class="nv">-</span> <span class="nv">c</span><span class="p">}</span><span class="p">)</span> <span class="nv">or</span> <span class="p">(</span><span class="nf">subset-sum-guile-dec</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}}</span>
	       <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
	       <span class="nv">s</span><span class="p">]))</span> <span class="c1">;; return boolean value</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="text-align: left;">It is also possible to use <b>return</b>
          keyword in function definition by <b>def </b>macro and have
          again another programming style with <b>if then else</b> that
          looks like traditionals language such as
          Python,Javascript,C/C++,etc... :</p>
        <p style="text-align: left;">This example mix many Scheme+ Style
          and illustrate the use of <b>return </b>in a Python/C++
          style:</p>
        <p style="text-align: left;"><br>
        </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"../SRFI/SRFI-105.rkt"</span>
<span class="c1">;;(require "../Scheme+.rkt")</span>
<span class="p">(</span><span class="nf">require</span> <span class="nv">Scheme-PLUS-for-Racket/Scheme+</span><span class="p">)</span>

<span class="p">(</span><span class="nf">def</span> <span class="p">(</span><span class="nf">subset-sum-dyna</span> <span class="nv">L</span> <span class="nv">t</span><span class="p">)</span>

  <span class="p">(</span><span class="nf">declare</span> <span class="nv">ls</span> <span class="nv">dyn</span><span class="p">)</span> <span class="c1">;; declare multiple variables</span>

  <span class="p">{</span><span class="nv">ls</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;-</span> <span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span><span class="p">}</span>

  <span class="c1">;; dyna[ls t] means : 0: unknown solution, 1: solution found, 2: no solution</span>

  <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">dyn</span> <span class="nv">&lt;&gt;</span> <span class="mi">0</span><span class="p">}</span> <span class="c1">;; IF or WHEN : it is the same thing here (only one statement)</span>
      <span class="p">(</span><span class="nf">return</span> <span class="p">(</span><span class="nf">one?</span> <span class="nv">dyn</span><span class="p">)))</span>

  <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">null?</span> <span class="nv">L</span><span class="p">)</span>
    <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">2</span><span class="p">}</span>
    <span class="p">(</span><span class="nf">return</span> <span class="no">#f</span><span class="p">))</span>

  <span class="p">{</span><span class="nv">c</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span>

  <span class="p">(</span><span class="nf">when</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">=</span> <span class="nv">t</span><span class="p">}</span>  <span class="c1">;; c is the solution</span>
    <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">(</span><span class="nf">return</span> <span class="no">#t</span><span class="p">))</span>

  <span class="p">{</span><span class="nv">R</span> <span class="nv">&lt;+</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">L</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; continue searching a solution in the rest</span>

  <span class="p">(</span><span class="nf">declare</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">{</span><span class="nv">c</span> <span class="nv">&gt;</span> <span class="nv">t</span><span class="p">}</span>  <span class="c1">;; c is to big to be a solution</span>
    <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">subset-sum-dyna</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}</span>
    <span class="c1">;; c is part of the solution or c is not part of solution</span>
    <span class="p">{</span><span class="nv">s</span> <span class="nv">&lt;-</span> <span class="p">{</span><span class="p">(</span><span class="nf">subset-sum-dyna</span> <span class="nv">R</span> <span class="p">{</span><span class="nv">t</span> <span class="nv">-</span> <span class="nv">c</span><span class="p">}</span><span class="p">)</span> <span class="nv">or</span> <span class="p">(</span><span class="nf">subset-sum-dyna</span> <span class="nv">R</span> <span class="nv">t</span><span class="p">)</span><span class="p">}}</span><span class="p">)</span>

  <span class="p">{</span><span class="nv">dyna</span><span class="p">[</span><span class="nf">ls</span> <span class="nv">t</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nf">one-two</span> <span class="nv">s</span><span class="p">)</span><span class="p">}</span>
  <span class="nv">s</span><span class="p">)</span> <span class="c1">;; return boolean value</span>


<span class="o"></span></code></pre>
        </figure>
        <h2><br>
        </h2>
        <h2><br>
        </h2>
        <h2>11<u>. History of project:</u></h2>
        <p>First i developped a new set of LET special forms with less
          bracket use and after i decided to use another assignment
          scheme based on infix operator for a little part,at some point
          the new assignment scheme was became so perfect that we no
          more need the set of LET special forms.But i also released the
          new set of LET special forms even if i consider those
          useless.Unfornunately Scheme do not allow to use only a single
          assignment operator because&nbsp; of declaration (define) of
          variables and set! are different and it does not exist a
          define-or-set! function. So i only had the choice to use 2
          assignment operators, one acting as <b>define</b> (<b>&lt;+</b>)
          and the other as <b>set!</b> (<b>&lt;-</b>) or a single
          assignment operator <b>&lt;- </b>and a declarative macro
          called <b>declare</b> which should be interesting for typed
          Scheme implementations too.</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2>12.<u>Additional documentation:</u></h2>
        <p><b>condx</b> is a macro that allow execution of arbitrary
          code between conditionals clauses,syntax is :</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">condx</span> <span class="p">[</span><span class="nf">condition</span> <span class="nv">statements</span> <span class="o">...</span><span class="p">]</span>

            <span class="p">[</span><span class="nf">exec</span> <span class="nv">statements</span> <span class="o">...</span> <span class="p">]</span>

            <span class="o">...</span>

            <span class="p">[</span><span class="k">else</span> <span class="nv">statements</span> <span class="o">...</span><span class="p">])</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="text-align: left;"><b>condx</b> is not a major feature
          of <b>Scheme+</b> but it can replace a lot of 'if then <b>elif'</b>,
          i dislike and still misunderstand sometimes, '<b>else if</b>'
          since BASIC !<br>
        </p>
        <p style="text-align: left;">&nbsp;<br>
        </p>
        <p style="text-align: left;">defining new functions with <b>def
          </b>instead of the classic define we can now use <b>return</b>
          to escape immediately returning the value v:</p>
        <p style="text-align: left;"><b>(return </b>v<b>) </b><b> </b></p>
        <p style="text-align: left;"><br>
        </p>
        <p style="text-align: left;"><b>$ </b>is a macro, it is a
          shortcut for <b>begin.<br>
          </b></p>
        <p style="text-align: left;">But <b>begin</b> is dual in
          Scheme, it expands differently in <i>expression </i>context
          and <i>definition </i>context. See this for more
          information:</p>
        <p style="text-align: left;"><a
            href="https://www.gnu.org/software/guile/manual/html_node/begin.html"
            moz-do-not-send="true">https://www.gnu.org/software/guile/manual/html_node/begin.html</a><br>
        </p>
        <p style="text-align: left;">For this reason it is sometimes
          necessary to use a classic <b>let </b>to create a block,for
          example when defining a <i>clozure.<br>
          </i></p>
        <p style="text-align: left;">As example consider those two
          definitions where the first - foo - is erroneous:<br>
        </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define</span> <span class="nv">foo</span> <span class="p">(</span><span class="k">begin</span> <span class="p">(</span><span class="k">define</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
                   <span class="p">(</span><span class="k">define</span> <span class="nv">y</span> <span class="mi">2</span><span class="p">)</span>
                   <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">bar</span> <span class="p">(</span><span class="k">let</span> <span class="p">()</span>
              <span class="p">(</span><span class="k">define</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
              <span class="p">(</span><span class="k">define</span> <span class="nv">y</span> <span class="mi">2</span><span class="p">)</span>
              <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span><span class="p">))))</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="text-align: left;">error: define: not allowed in an
          expression context in: (define x 1)<br>
        </p>
        <p style="text-align: left;">for this reason i provide a <b>&amp;
          </b>macro that is defined with a <b>let </b>as this:<br>
        </p>
        <p style="text-align: left;"> </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="k">define-syntax</span> <span class="nv">&amp;</span>
  <span class="p">(</span><span class="k">syntax-rules</span> <span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">ev</span><span class="p">)</span>  <span class="nv">ev</span><span class="p">)</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">ev</span> <span class="o">...</span><span class="p">)</span> <span class="p">(</span><span class="k">let</span> <span class="p">()</span> <span class="nv">ev</span> <span class="o">...</span><span class="p">))))</span>


<span class="o"></span></code></pre>
        </figure>
        <p>We can now define the previous bar function in Scheme+ like
          this:<br>
        </p>
        <p> </p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">def</span> <span class="nv">bar</span> <span class="p">(</span><span class="nf">&amp;</span> <span class="p">(</span><span class="nf">declare</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
            <span class="p">{</span><span class="nv">x</span> <span class="nv">&lt;-</span> <span class="mi">1</span><span class="p">}</span> 
            <span class="p">{</span><span class="nv">y</span> <span class="nv">&lt;-</span> <span class="mi">2</span><span class="p">}</span>
            <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">t</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">t</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">bar</span> <span class="mi">7</span><span class="p">)</span>
<span class="mi">10</span>


<span class="o"></span></code></pre>
        </figure>
        <p style="text-align: left;"> </p>
        <h2 style=" text-align: left;">13.<u>Caveats:</u></h2>
        <p>Inherent to Scheme language it as not been possible to
          simplify more assignment operator in a single one case. This
          is due to the fact that it can not be written a macro that do
          define-or-set! and that define can not be placed any where.
          See discussion in <a
href="https://lists.gnu.org/archive/html/guile-devel/2021-09/msg00031.html"
            target="_blank">Guile devel mailing list archive in
            September 2021</a> For the place of define, by chance,some
          Scheme implementation allow define to be placed almost
          anywhere.</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2>14.<u>Implementation:</u></h2>
        <p>Mainly with <b>Scheme macros</b> which are not recursive
          (except in some obsolete features),so expansion is fast and
          code also. It also allows a great portabilty from one Scheme
          implementation to another one.</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2>15.<u>Future:</u></h2>
        <p>Scheme+ will continue to be implemented for other Scheme
          implementations.</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2><u>16.Extra features:</u> </h2>
        <p>Other features include a part of my personal functional
          library when functions are not existing already in some <a
            href="https://srfi.schemers.org/" target="_blank">SRFI
            (Scheme Request For Implementations)</a>.</p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2>17.<u>Obsolete features:</u></h2>
        <p>As mentioned early the project idea was initially to enhance
          the set of LET special form. The use of the LET set is no more
          need with the new assignment operator but i release anyway
          those set of enhanced and simplified LETs, i just give some
          examples as names are self-explanatory.</p>
        <p>The way to be able to use the new set of LET special form is
          to load the file let.scm which is available in the Scheme+
          directory:</p>
        <p><b>(load "let.scm")</b></p>
        <p>Examples:</p>
        <p><!-- HTML generated using hilite.me --></p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">let&lt;-rec*</span> <span class="p">[</span><span class="nf">x</span> <span class="nv">&lt;-</span> <span class="mi">1</span>
            <span class="nv">y</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nv">z</span> <span class="nv">&lt;-</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">y</span><span class="p">)]</span>
         <span class="nv">z</span><span class="p">)</span>
<span class="mi">4</span>


<span class="o"></span></code></pre>
        </figure>
        <p> </p>
        <br>
        <p>a few others special forms simplifying the LETs (but still
          obsolete in my opinion):</p>
        <p>let-arrow* :</p>
        <p><!-- HTML generated using hilite.me --></p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">let-arrow*</span> <span class="p">(</span><span class="nf">x</span> <span class="p">←</span> <span class="mi">1</span>
 	     <span class="nv">y</span> <span class="p">←</span> <span class="p">{</span><span class="nv">x</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span>
           <span class="nv">y</span><span class="p">)</span>
<span class="mi">2</span>


<span class="p">(</span><span class="nf">let-arrow*</span> <span class="p">(</span><span class="p">{</span><span class="nv">x</span> <span class="p">←</span> <span class="mi">1</span><span class="p">}</span>
             <span class="p">{</span><span class="nv">y</span> <span class="p">←</span> <span class="p">{</span><span class="nv">x</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}}</span><span class="p">)</span>
           <span class="nv">x</span>
           <span class="nv">y</span><span class="p">)</span>

<span class="mi">2</span>


<span class="p">(</span><span class="nf">let-arrow*</span> <span class="p">[</span> <span class="nv">x</span> <span class="mi">1</span>
              <span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
              <span class="nv">z</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="nv">y</span><span class="p">)</span> <span class="p">]</span>
            <span class="nv">z</span> <span class="nv">y</span><span class="p">)</span>

<span class="mi">2</span>

<span class="o"></span></code></pre>
        </figure>
        <p> </p>
        <p><br>
        </p>
        <p>letrec-arrow* , the same as let-arrow* but for recursive
          functions:</p>
        <figure class="highlight">
          <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>

<span class="p">(</span><span class="nf">letrec-arrow*</span> <span class="p">[</span> <span class="nv">fact</span> <span class="p">←</span> <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span>
 			  <span class="p">(</span><span class="k">if</span>  <span class="p">{</span><span class="nv">n</span> <span class="nv">=</span> <span class="mi">1</span><span class="p">}</span>
 			       <span class="mi">1</span>
                               <span class="p">{</span><span class="nv">n</span> <span class="nv">*</span> <span class="p">(</span><span class="nf">fact</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">-</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span><span class="p">}</span> <span class="p">))</span> <span class="p">]</span>
 	       <span class="p">(</span><span class="nf">fact</span> <span class="mi">5</span><span class="p">))</span>

<span class="mi">120</span>

<span class="o"></span></code></pre>
        </figure>
        <br>
        <h2><br>
        </h2>
        <h2><u>18.Comments:</u></h2>
        <p>Github web site technology force me to convert this page in
          Github Markup Language, perheaps instead of HTML should i have
          make it directly in GML but i did not know it existed before
          doing it. I did not want to make this documentation so long
          and graphically complex to set up. Well it's done! <i><b>i
              hope you get interest in reading at least 10% :-)</b></i>
          . And get as pleasure to read and use than i take making and
          writing it.<br>
          <b>This documentation is at end and it is quite impressive how
            long it takes to document things! </b>Even if i
          suppose&nbsp; i could have forget&nbsp; things to talk about.<br>
        </p>
        <p><br>
        </p>
        <p><br>
        </p>
        <h2>19. <u>Special characters (for special people):</u></h2>
        <p>This is about the optional replacement symbols for some
          operators:</p>
        <br>
        <br>
        <p>The hexadécimal unicode can be entered under Linux with :
          Ctrl-Shift u following with the hexadecimal unicode and Enter
          or Space bar,
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
          on <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">Mac OS use </a> <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">CTRL+CMD+space to bring up the
            characters
            popover, </a> <a
href="https://apple.stackexchange.com/questions/183045/how-can-i-type-unicode-characters-without-using-the-mouse"
            moz-do-not-send="true">then type in u + unicode and hit
            Enter to
            get it</a>. And in Emacs you can insert an unicode char with
          the sequence:
          <meta http-equiv="content-type" content="text/html;
            charset=UTF-8">
          <code>‘C-x 8 RET’</code> followed with unicode of the
          character
          you want.<br>
        </p>
        <ul>
          <li>&lt;- : ← , unicode 2190 (this doesn't looks like but it
            is an hexadecimal number !) This operator assignment was
            used in <a
              href="https://en.wikipedia.org/wiki/APL_%28programming_language%29"
              target="_blank">APL</a> </li>
          <li>-&gt; : → ,unicode 2192</li>
          <li>&lt;+ : ⥆ , unicode 2946 (Add a variable in the current
            environment)</li>
          <li>+&gt; : ⥅ , unicode 2945</li>
          <li>&lt;&gt; : ≠ , unicode 2260</li>
        </ul>
        <p>Example:</p>
        <pre>scheme@(guile-user)&gt; {v ⥆ 7}
scheme@(guile-user)&gt; v
7
</pre>
        <p> </p>
        <div style="text-align: left;"><br>
        </div>
        <div style="text-align: left;">
          <h2><u>20. Scheme+ in action:</u></h2>
          <p>Example based on the <a
              href="https://en.wikipedia.org/wiki/Petrick%27s_method"
              target="_blank">Petrick method</a> algorithm:</p>
          <p><br>
          </p>
          <figure class="highlight">
            <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>
<span class="p">(</span><span class="nf">def</span> <span class="p">(</span><span class="nf">Petrick</span> <span class="nv">non-essential-prime-implicants</span> <span class="nv">var-list</span><span class="p">)</span>

  <span class="c1">;; create the conjunction of disjunction expression</span>

  <span class="p">(</span><span class="nf">declare</span> <span class="nv">mt</span> <span class="nv">conj-expr</span> <span class="nv">prim-imp</span> <span class="nv">col</span> <span class="nv">disj-expr</span> <span class="nv">disj-expr-sorted</span> <span class="nv">mt-var</span> <span class="nv">missing-term</span><span class="p">)</span>

  <span class="p">(</span><span class="nf">display-nl</span> <span class="s">"Entering Petrick..."</span><span class="p">)</span>
  
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">x</span> <span class="mi">1</span> <span class="nv">lgt-mt</span><span class="p">)</span> <span class="c1">;; loop over minterms</span>
       
       <span class="p">{</span><span class="nv">mt</span> <span class="p">←</span> <span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="mi">0</span><span class="p">]</span><span class="p">}</span>
       
       <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">member</span> <span class="nv">mt</span> <span class="nv">non-expressed-minterms</span><span class="p">)</span> <span class="c1">;; non expressed minterm</span>
	 
	 <span class="p">{</span><span class="nv">col</span> <span class="p">←</span> <span class="o">'</span><span class="p">()</span><span class="p">}</span>
	 
	 <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">1</span> <span class="nv">lgt-pi</span><span class="p">)</span> <span class="c1">;; loop over prime implicants</span>
	      
	      <span class="p">{</span><span class="nv">prim-imp</span> <span class="p">←</span> <span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span> <span class="c1">;; prime implicant</span>
	      
	      <span class="c1">;; check wether prime implicant is a non essential one?</span>
	      <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">member</span> <span class="nv">prim-imp</span> <span class="nv">non-essential-prime-implicants</span><span class="p">)</span>
		
		<span class="c1">;; is the non essential prime implicant expressing this minterms?</span>
		<span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">string=?</span> <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span> <span class="s">" * "</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">insert-set!</span> <span class="p">(</span><span class="nf">minterm-&gt;var</span> <span class="nv">prim-imp</span><span class="p">)</span> <span class="nv">col</span><span class="p">))))</span>
	 
	 <span class="c1">;; end for y</span>
	 
	 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">singleton-set?</span> <span class="nv">col</span><span class="p">)</span>
	     <span class="p">{</span><span class="nv">col</span> <span class="p">←</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">col</span><span class="p">)</span><span class="p">}</span>  <span class="c1">;; ( V ) -&gt; V</span>
	     <span class="p">(</span><span class="nf">insert-set!</span> <span class="ss">'or</span> <span class="nv">col</span><span class="p">))</span>  <span class="c1">;; (V1 V2 ...) -&gt; (or V1 V2 ...)</span>
	 
	 <span class="p">(</span><span class="nf">insert-set!</span> <span class="nv">col</span> <span class="nv">conj-expr</span><span class="p">)))</span>
  
  <span class="c1">;; end for x</span>

  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">singleton-set?</span> <span class="nv">conj-expr</span><span class="p">)</span>
      <span class="p">{</span><span class="nv">conj-expr</span> <span class="p">←</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">conj-expr</span><span class="p">)</span><span class="p">}</span>  <span class="c1">;; ( conj-expr ) -&gt; conj-expr</span>
      <span class="p">(</span><span class="nf">insert-set!</span> <span class="ss">'and</span> <span class="nv">conj-expr</span><span class="p">))</span>  <span class="c1">;; (e1 e2 ...) -&gt; (and e1 e2 ...)</span>


  <span class="c1">;; find the disjunctive form</span>
  <span class="p">{</span><span class="nv">disj-expr</span> <span class="p">←</span> <span class="p">(</span><span class="nf">dnf-n-arity-simp</span> <span class="nv">conj-expr</span><span class="p">)</span><span class="p">}</span>
  
  <span class="c1">;; sorting terms</span>
  <span class="c1">;; sort by x &lt; 1 &lt; 0</span>
  <span class="p">{</span><span class="nv">disj-expr-sorted</span> <span class="p">←</span> <span class="p">(</span><span class="nf">sort-arguments-in-operation-most-little-literal-first</span> <span class="nv">disj-expr</span><span class="p">)</span><span class="p">}</span>
 
  <span class="c1">;; get the shortest minterm</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">isOR-AND?</span> <span class="nv">disj-expr-sorted</span><span class="p">)</span>
      <span class="p">{</span><span class="nv">mt-var</span> <span class="p">←</span> <span class="p">(</span><span class="nf">first</span> <span class="p">(</span><span class="nf">args</span> <span class="nv">disj-expr-sorted</span><span class="p">))</span><span class="p">}</span>
      <span class="p">{</span><span class="nv">mt-var</span> <span class="p">←</span> <span class="nv">disj-expr-sorted</span><span class="p">}</span><span class="p">)</span>

  <span class="p">{</span><span class="nv">mt</span> <span class="p">←</span> <span class="p">(</span><span class="nf">var-&gt;minterm</span> <span class="nv">mt-var</span><span class="p">)</span><span class="p">}</span>

  <span class="c1">;; TODO: possible bug missing term could be an expression ? (multiple terms)</span>
  <span class="p">{</span><span class="nv">missing-term</span> <span class="p">←</span> <span class="p">(</span><span class="nf">essential-prime-implicants-list-&gt;formula</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">mt</span><span class="p">)</span>
							    <span class="nv">var-list</span><span class="p">)</span><span class="p">}</span>

  <span class="nv">missing-term</span>
      
<span class="p">)</span>

<span class="o"></span></code></pre>
          </figure>
          <br>
          <br>
          <p>Example based on the <a
              href="https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm"
              target="_blank">Quine–McCluskey</a> algorithm:</p>
          <p><br>
          </p>
          <figure class="highlight">
            <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>
<span class="p">(</span><span class="nf">def</span> <span class="p">(</span><span class="nf">Quine-Mc-Cluskey</span> <span class="nv">disj-norm-form</span> <span class="nv">var-list</span><span class="p">)</span>
     
     <span class="p">(</span><span class="nf">display-nl</span> <span class="s">"Entering Quine-Mc-Cluskey"</span><span class="p">)</span>
     
     <span class="p">{</span><span class="nv">and-terms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">args</span> <span class="nv">disj-norm-form</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; conjunctives minterms</span>
     <span class="c1">;; variable list of expanded minterms </span>
     <span class="p">{</span><span class="nv">expanded-var-terms</span>  <span class="p">⥆</span> <span class="p">(</span><span class="nf">$</span> <span class="p">{</span><span class="nv">debug-mode-save</span> <span class="p">←</span> <span class="nv">debug-mode</span><span class="p">}</span>
			        <span class="p">{</span><span class="nv">debug-mode</span>  <span class="p">←</span> <span class="no">#t</span><span class="p">}</span>
				<span class="p">(</span><span class="nf">when</span> <span class="nv">debug-mode</span>
				  <span class="p">(</span><span class="nf">dv</span> <span class="nv">and-terms</span><span class="p">))</span> <span class="c1">;; dv:display value</span>
				<span class="p">{</span><span class="nv">debug-mode</span>  <span class="p">←</span> <span class="nv">debug-mode-save</span><span class="p">}</span>
				<span class="p">(</span><span class="nb">apply</span> <span class="nv">append</span>
				       <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">min-term</span><span class="p">)</span>
					      <span class="p">(</span><span class="nf">expand-minterm</span> <span class="nv">var-list</span> <span class="nv">min-term</span><span class="p">))</span>
					    <span class="nv">and-terms</span><span class="p">)))</span><span class="p">}</span>

     <span class="p">{</span><span class="nv">sorted-expanded-var-terms</span>  <span class="p">⥆</span> <span class="p">(</span><span class="nb">map</span> <span class="nv">sort-arguments</span> <span class="nv">expanded-var-terms</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; sorted variable list of expanded minterms</span>
     <span class="p">{</span><span class="nv">binary-minterms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">map</span> <span class="nv">var-&gt;binary</span> <span class="nv">sorted-expanded-var-terms</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; minterms in binary form</span>
     <span class="p">{</span><span class="nv">sorted-binary-minterms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">sort</span> <span class="nv">binary-minterms</span> <span class="nv">minterm-binary-weight-number&lt;?</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; sorted binary minterms</span>
     <span class="p">{</span><span class="nv">uniq-sorted-binary-minterms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">remove-duplicates-sorted</span> <span class="nv">sorted-binary-minterms</span><span class="p">)</span><span class="p">}</span>  <span class="c1">;; prevoir uniq pourquoi???? sais plus !</span>
     <span class="p">{</span><span class="nv">minterms</span> <span class="p">⥆</span> <span class="nv">uniq-sorted-binary-minterms</span><span class="p">}</span>
     <span class="p">{</span><span class="nv">set-of-sets-of-minterms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">order-by-weight-minterms</span> <span class="nv">uniq-sorted-binary-minterms</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; set of sets of minterms ordered by weight</span>
     <span class="p">{</span><span class="nv">unified-minterms</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">$</span> <span class="p">{</span><span class="nv">debug-mode-save</span> <span class="p">←</span> <span class="nv">debug-mode</span><span class="p">}</span>
			     <span class="p">{</span><span class="nv">debug-mode</span> <span class="p">←</span> <span class="no">#t</span><span class="p">}</span>
			     <span class="p">(</span><span class="nf">when</span> <span class="nv">debug-mode</span> <span class="p">(</span><span class="nf">display-nl</span> <span class="s">"Quine-Mc-Cluskey:"</span><span class="p">))</span>
			     <span class="p">(</span><span class="nf">init-hash-table-with-set-and-value</span> <span class="nv">minterms-ht</span> <span class="nv">minterms</span> <span class="no">#f</span><span class="p">)</span>
			     <span class="p">(</span><span class="nf">dv</span> <span class="nv">minterms-ht</span><span class="p">)</span>
			     <span class="p">{</span><span class="nv">debug-mode</span> <span class="p">←</span> <span class="nv">debug-mode-save</span><span class="p">}</span>
			     <span class="p">(</span><span class="nf">recursive-unify-minterms-set-of-sets</span>  <span class="nv">set-of-sets-of-minterms</span><span class="p">))</span><span class="p">}</span>
	 
     <span class="p">{</span><span class="nv">essential-prime-implicants</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">$</span> <span class="p">{</span><span class="nv">prime-implicants-lst</span> <span class="p">←</span> <span class="p">(</span><span class="nf">$</span> <span class="p">{</span><span class="nv">debug-mode</span> <span class="p">←</span> <span class="nv">debug-mode-save</span><span class="p">}</span>
								  <span class="p">(</span><span class="nf">prime-implicants</span> <span class="nv">minterms-ht</span><span class="p">))</span><span class="p">}</span>
				       <span class="p">(</span><span class="nf">identify-essential-prime-implicants</span> <span class="nv">prime-implicants-lst</span> <span class="nv">minterms</span><span class="p">))</span><span class="p">}</span>
       
     <span class="c1">;; dv : display value</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">disj-norm-form</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">var-list</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">and-terms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">expanded-var-terms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">sorted-expanded-var-terms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">binary-minterms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">sorted-binary-minterms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">uniq-sorted-binary-minterms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dvsos</span> <span class="nv">set-of-sets-of-minterms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">unified-minterms</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">minterms-ht</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">prime-implicants-lst</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">essential-prime-implicants</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">display-nl</span> <span class="s">"function expressed by essential prime implicants ?"</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">dv</span> <span class="nv">feepi</span><span class="p">)</span>
     <span class="nv">essential-prime-implicants</span><span class="p">)</span>


<span class="c1">;; e element</span>
<span class="c1">;; s set</span>
<span class="c1">;; sos set of sets</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">put-elements-of-set-of-sets-in-minterms-ht</span> <span class="nv">sos</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">map</span> <span class="c1">;; deal with sets of the 'set of sets'</span>
   <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">map</span> <span class="c1">;; deal with elements of a set</span>
		<span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">e</span><span class="p">)</span> <span class="p">{</span><span class="nv">minterms-ht</span><span class="p">[</span><span class="nf">e</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="no">#f</span><span class="p">}</span><span class="p">)</span>
		<span class="nv">s</span><span class="p">))</span>
   <span class="nv">sos</span><span class="p">))</span>

<span class="c1">;; unify function for two minterms</span>
<span class="c1">;;</span>
<span class="c1">;; (function-unify-two-minterms-and-tag '(1 0 0 0) '(1 0 1 0)) -&gt; '(1 0 x 0)</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">function-unify-two-minterms-and-tag</span> <span class="nv">mt1</span> <span class="nv">mt2</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">res</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">unify-two-minterms</span> <span class="nv">mt1</span> <span class="nv">mt2</span><span class="p">)</span><span class="p">}</span>
  <span class="p">(</span><span class="nf">when</span> <span class="nv">res</span>
    <span class="p">{</span><span class="nv">minterms-ht</span><span class="p">[</span><span class="nf">mt1</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="no">#t</span><span class="p">}</span>
    <span class="p">{</span><span class="nv">minterms-ht</span><span class="p">[</span><span class="nf">mt2</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="no">#t</span><span class="p">}</span><span class="p">)</span>
  <span class="nv">res</span><span class="p">)</span>



<span class="c1">;; (init-hash-table-with-set-and-value ht '((1 0 0 0) (0 1 0 1) (1 0 1 0) (1 1 0 0) (0 1 1 1) (1 1 0 1) (1 1 1 0) (1 1 1 1)) #f)</span>
<span class="c1">;; '(#&lt;void&gt; #&lt;void&gt; #&lt;void&gt; #&lt;void&gt; #&lt;void&gt; #&lt;void&gt; #&lt;void&gt; #&lt;void&gt;)</span>
<span class="c1">;; &gt; ht</span>
<span class="c1">;; '#hash(((1 1 0 1) . #f)</span>
<span class="c1">;;        ((1 1 0 0) . #f)</span>
<span class="c1">;;        ((0 1 0 1) . #f)</span>
<span class="c1">;;        ((0 1 1 1) . #f)</span>
<span class="c1">;;        ((1 0 0 0) . #f)</span>
<span class="c1">;;        ((1 1 1 1) . #f)</span>
<span class="c1">;;        ((1 1 1 0) . #f)</span>
<span class="c1">;;        ((1 0 1 0) . #f))</span>

<span class="c1">;; used by Quine - Mc Cluskey</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">init-hash-table-with-set-and-value</span> <span class="nv">ht</span> <span class="nv">s</span> <span class="nv">val</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">"init-hash-table-with-set-and-value"</span><span class="p">)</span> <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">ht</span> <span class="p">←</span> <span class="p">(</span><span class="nf">make-hash-table</span><span class="p">)</span><span class="p">}</span>
  <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">e</span><span class="p">)</span> <span class="p">{</span><span class="nv">ht</span><span class="p">[</span><span class="nf">e</span><span class="p">]</span> <span class="nv">&lt;-</span> <span class="nv">val</span><span class="p">}</span><span class="p">)</span> <span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">"end of init-hash-table-with-set-and-value"</span><span class="p">)</span> <span class="p">(</span><span class="nb">newline</span><span class="p">))</span>


<span class="c1">;; list of non expressed minterms</span>
<span class="p">{</span><span class="nv">non-expressed-minterms</span> <span class="p">⥆</span> <span class="o">'</span><span class="p">()</span><span class="p">}</span> <span class="c1">;; could also be done with (declare non-expressed-minterms)</span>

<span class="c1">;; iepi : identifying essential prime implicant array</span>
<span class="c1">;; first line : minterms</span>
<span class="c1">;; first row : prime-implicants</span>
<span class="c1">;; for now i do not know the array dimension</span>
<span class="p">(</span><span class="nf">declare</span> <span class="nv">iepi</span> <span class="nv">lgt-pi</span> <span class="nv">lgt-mt</span><span class="p">)</span>

<span class="c1">;; example part of output:</span>

<span class="c1">;; {iepi[1 2]} = 0</span>
<span class="c1">;; {iepi[1 2] ← 1} = 1</span>
<span class="c1">;; #(() (0 0 0 0) (0 0 0 1) (0 0 1 0) (1 0 0 0) (0 1 0 1) (0 1 1 0) (1 0 0 1) (1 0 1 0) (0 1 1 1) (1 1 1 0))</span>
<span class="c1">;; #(0 0 0 0 0 0 0 0 0 0 0)</span>
<span class="c1">;; #(0 1 0 0 0 0 0 0 0 0 0)</span>
<span class="c1">;; #(0 0 0 0 0 0 0 0 0 0 0)</span>
<span class="c1">;; #(0 0 0 0 0 0 0 0 0 0 0)</span>
<span class="c1">;; #(0 0 0 0 0 0 0 0 0 0 0)</span>
<span class="c1">;; #(0 0 0 0 0 0 0 0 0 0 0)</span>

<span class="c1">;; iepi = </span>
<span class="c1">;; #(() (0 0 0 0) (0 0 0 1) (0 0 1 0) (1 0 0 0) (0 1 0 1) (0 1 1 0) (1 0 0 1) (1 0 1 0) (0 1 1 1) (1 1 1 0))</span>
<span class="c1">;; #((0 x 0 1)      *           *                     )</span>
<span class="c1">;; #((0 1 x 1)                  *               *     )</span>
<span class="c1">;; #((0 1 1 x)                      *           *     )</span>
<span class="c1">;; #((x x 1 0)          *           *       *      (*))</span>
<span class="c1">;; #((x 0 0 x)  *   *       *          (*)            )</span>
<span class="c1">;; #((x 0 x 0)  *       *   *               *         )</span>


<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">identify-essential-prime-implicants</span>  <span class="nv">prime-implicants</span> <span class="nv">minterms</span><span class="p">)</span>
  
  <span class="p">{</span><span class="nv">vct-prime-implicants</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">list-&gt;vector</span> <span class="nv">prime-implicants</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">essential-prime-implicants-list</span> <span class="p">⥆</span> <span class="o">'</span><span class="p">()</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">cpt-mt</span> <span class="p">⥆</span> <span class="mi">0</span><span class="p">}</span> <span class="c1">;; counter of minterms</span>
  <span class="p">{</span><span class="nv">y-pos-epi</span> <span class="p">⥆</span> <span class="mi">0</span><span class="p">}</span> <span class="c1">;; position of essential prime implicant in colomn if there exists one</span>
  <span class="p">{</span><span class="nv">star-in-column</span> <span class="p">⥆</span> <span class="no">#f</span><span class="p">}</span> <span class="c1">;; at the beginning</span>
  
  <span class="p">{</span><span class="nv">lgt-pi</span> <span class="p">←</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">prime-implicants</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">lgt-mt</span> <span class="p">←</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">minterms</span><span class="p">)</span><span class="p">}</span>
  
  <span class="c1">;; identifying essential prime implicant array</span>
  <span class="c1">;; first line : minterms</span>
  <span class="c1">;; first row : prime-implicants</span>
  <span class="p">{</span><span class="nv">iepi</span> <span class="p">←</span> <span class="p">(</span><span class="nf">make-array-2d</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">lgt-mt</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">lgt-pi</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span><span class="p">}</span> <span class="c1">;; two dimensions array</span>
 
  <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span><span class="p">]</span> <span class="p">←</span> <span class="p">(</span><span class="nb">list-&gt;vector</span> <span class="p">(</span><span class="nb">cons</span> <span class="o">'</span><span class="p">()</span> <span class="nv">minterms</span><span class="p">))</span><span class="p">}</span>
 
  <span class="c1">;; set the title line</span>

  <span class="c1">;; construction of the array</span>
  <span class="c1">;; set the left column containing prime implicants </span>
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">lgt-pi</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)]</span> <span class="p">←</span> <span class="p">{</span><span class="nv">vct-prime-implicants</span><span class="p">[</span><span class="nf">y</span><span class="p">]</span><span class="p">}}</span><span class="p">)</span>
 
  <span class="c1">;; identify prime implicants</span>
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">x</span> <span class="mi">1</span> <span class="nv">lgt-mt</span><span class="p">)</span>
       
       <span class="p">{</span><span class="nv">cpt-mt</span> <span class="p">←</span> <span class="mi">0</span><span class="p">}</span>
       
       <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">1</span> <span class="nv">lgt-pi</span><span class="p">)</span>

	    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">compare-minterm-and-implicant</span> <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span>
					       <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="mi">0</span><span class="p">]</span><span class="p">}</span><span class="p">)</span>
		<span class="c1">;; then</span>
		<span class="p">(</span><span class="nf">$</span>
		  <span class="p">(</span><span class="nf">incf</span> <span class="nv">cpt-mt</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">1</span> <span class="nv">cpt-mt</span><span class="p">)</span>
			<span class="p">{</span><span class="nv">y-pos-epi</span> <span class="p">←</span> <span class="nv">y</span><span class="p">}</span><span class="p">)</span> <span class="c1">;; position of essential prime implicant</span>
		  <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">←</span> <span class="s">" * "</span><span class="p">}</span><span class="p">)</span>
		
		<span class="c1">;; else</span>
		<span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">←</span> <span class="s">"   "</span><span class="p">}</span><span class="p">))</span> <span class="c1">;; end for y</span>
       
       <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">1</span> <span class="nv">cpt-mt</span><span class="p">)</span> <span class="c1">;; essential prime implicant</span>
	     <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y-pos-epi</span><span class="p">]</span> <span class="p">←</span> <span class="s">"(*)"</span><span class="p">}</span>
	     <span class="c1">;; add essential prime implicant to list</span>
	     <span class="p">{</span><span class="nv">essential-prime-implicants-list</span> <span class="p">←</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span> <span class="nv">y-pos-epi</span><span class="p">]</span><span class="p">}</span> <span class="nv">essential-prime-implicants-list</span><span class="p">)</span><span class="p">}</span><span class="p">)</span>

     <span class="p">)</span> <span class="c1">;; end for x</span>
  
  <span class="p">{</span><span class="nv">essential-prime-implicants-list</span> <span class="p">←</span> <span class="p">(</span><span class="nf">remove-duplicates</span> <span class="nv">essential-prime-implicants-list</span><span class="p">)</span><span class="p">}</span>

  <span class="p">{</span><span class="nv">feepi</span> <span class="p">←</span> <span class="no">#t</span><span class="p">}</span>
  
  <span class="c1">;; check if function is expressed by essential implicants</span>
  <span class="p">(</span><span class="nf">for/break</span> <span class="nv">break-x</span> <span class="p">(</span><span class="nf">x</span> <span class="mi">1</span> <span class="nv">lgt-mt</span><span class="p">)</span> <span class="c1">;; loop over minterms</span>
	     
	     <span class="p">(</span><span class="nf">for/break</span> <span class="nv">break-y</span> <span class="p">(</span><span class="nf">y</span> <span class="mi">1</span> <span class="nv">lgt-pi</span><span class="p">)</span> <span class="c1">;; loop over prime implicants</span>

			<span class="c1">;; check wether prime implicant is an essential one?</span>
			<span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="nb">member</span> <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">0</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span> <span class="nv">essential-prime-implicants-list</span><span class="p">)</span>
			  			      <span class="c1">;; is the essential prime implicant expressing this minterms?</span>
			      <span class="p">(</span><span class="nf">when</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">string=?</span>  <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span> <span class="s">"(*)"</span><span class="p">)</span>
					<span class="p">(</span><span class="nb">string=?</span>  <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="nv">y</span><span class="p">]</span><span class="p">}</span> <span class="s">" * "</span><span class="p">))</span>
				    
	
				    <span class="p">{</span><span class="nv">star-in-column</span> <span class="p">←</span> <span class="no">#t</span><span class="p">}</span>
				    
				    <span class="p">(</span><span class="nf">break-y</span><span class="p">))))</span> <span class="c1">;; that's enought! we know the minterm is expressed.</span>

	     <span class="c1">;; end for/break break-y</span>
	     
	     <span class="p">(</span><span class="nf">unless</span> <span class="nv">star-in-column</span>
		     <span class="p">{</span><span class="nv">feepi</span> <span class="p">←</span> <span class="no">#f</span><span class="p">}</span> <span class="c1">;; function non expressed by prime implicants</span>
		     <span class="c1">;; add minterm to non expressed minterms list</span>
		     <span class="p">{</span><span class="nv">non-expressed-minterms</span> <span class="p">←</span> <span class="p">(</span><span class="nf">insert</span> <span class="p">{</span><span class="nv">iepi</span><span class="p">[</span><span class="nf">x</span> <span class="mi">0</span><span class="p">]</span><span class="p">}</span> <span class="nv">non-expressed-minterms</span><span class="p">)</span><span class="p">}</span>
		     <span class="c1">;;(break-x) ;; removed break-x as we have to check all the minterms now</span>
		     <span class="p">)</span>
	     
	     <span class="p">{</span><span class="nv">star-in-column</span> <span class="p">←</span> <span class="no">#f</span><span class="p">}</span><span class="p">)</span>  <span class="c1">;; set it for the next loop</span>
  <span class="c1">;; end for/break break-x</span>

  <span class="nv">essential-prime-implicants-list</span><span class="p">)</span>


<span class="o"></span></code></pre>
          </figure>
          <br>
          <br>
	  <br>
	  <br>
	  <h2><u>21. Contributors:</u></h2>
	  Maxime Devos<br>
	  Rebecca Turner<br>
	  <br>
          <h2><u>22. DrRacket graphic example in Scheme+:</u></h2>
          <p>This example&nbsp; create a graphic application that draw
            interactively&nbsp; the <a
              href="https://en.wikipedia.org/wiki/Riemann_zeta_function"
              moz-do-not-send="true">ζ complex Riemann function</a> of
            the point value under mouse pointer. It also have a more
            accurate mode but with no interaction (because Riemann zeta
            function is very time consuming to compute) , the value is
            possible for any complex number z with real part greater
            than 1 (no analytic continuation in this version):<br>
          </p>
          <p align="center"><br>
          </p>
          <div align="center"><img
              src="Scheme+io_fichiers/zeta-DrRacket.png"
              moz-do-not-send="true" alt="zeta riemann" width="700"
              border="3" height="438"><br>
          </div>
          <br>
          <br>
          <br>
          And here is the code (available in the example directory of
          the Scheme+ package):<br>
          <br>
          <figure class="highlight">
            <pre><code class="language-scheme" data-lang="scheme"><span class="o"></span>
<span class="o">#</span><span class="nv">lang</span> <span class="nv">reader</span> <span class="s">"../SRFI/SRFI-105.rkt"</span>

<span class="c1">;;(require Scheme-PLUS-for-Racket/Scheme+)</span>

<span class="p">(</span><span class="nf">require</span> <span class="s">"../Scheme+.rkt"</span><span class="p">)</span>

<span class="p">(</span><span class="nf">include</span> <span class="s">"../library/increment.scm"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">include</span> <span class="s">"../library/for-next-step.scm"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">include</span> <span class="s">"../library/repeat-until.scm"</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">racket/gui/base</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">animation-mode</span> <span class="no">#f</span><span class="p">)</span>

<span class="p">{</span><span class="nv">xws</span> <span class="p">⥆</span> <span class="mi">1000</span><span class="p">}</span> <span class="c1">;; X window size</span>
<span class="p">{</span><span class="nv">yws</span> <span class="p">⥆</span> <span class="mi">800</span><span class="p">}</span> <span class="c1">;; Y window size</span>

<span class="p">{</span><span class="nv">ywsp</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">yws</span> <span class="nv">-</span> <span class="mi">200</span><span class="p">}}</span> <span class="c1">;; Y window size for plot</span>

<span class="c1">; Make a frame by instantiating the frame% class</span>
<span class="p">{</span><span class="nv">frame0</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">frame%</span> <span class="p">[</span><span class="nf">label</span> <span class="s">"Example"</span><span class="p">]</span>
	       <span class="p">[</span><span class="nf">width</span> <span class="nv">xws</span><span class="p">]</span>
	       <span class="p">[</span><span class="nf">height</span> <span class="nv">yws</span><span class="p">])</span><span class="p">}</span>


<span class="c1">; Make a static text message in the frame</span>
<span class="p">{</span><span class="nv">msg</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">message%</span> <span class="p">[</span><span class="nf">parent</span> <span class="nv">frame0</span><span class="p">]</span>
	    <span class="p">[</span><span class="nf">label</span> <span class="s">"No events so far..."</span><span class="p">])</span><span class="p">}</span>
 
<span class="c1">;; Make a button in the frame</span>
<span class="p">(</span><span class="nf">new</span> <span class="nv">button%</span> <span class="p">[</span><span class="nf">parent</span> <span class="nv">frame0</span><span class="p">]</span>
             <span class="p">[</span><span class="nf">label</span> <span class="s">"Exit"</span><span class="p">]</span>
             <span class="c1">; Callback procedure for a button click:</span>
             <span class="p">[</span><span class="nf">callback</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">button</span> <span class="nv">event</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">send</span> <span class="nv">msg</span> <span class="nv">set-label</span> <span class="s">"Button click"</span><span class="p">)</span>
			 <span class="p">(</span><span class="nf">exit</span><span class="p">))])</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">no-pen</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">pen%</span> <span class="p">[</span><span class="nf">style</span> <span class="ss">'transparent</span><span class="p">]))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">no-brush</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">brush%</span> <span class="p">[</span><span class="nf">style</span> <span class="ss">'transparent</span><span class="p">]))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">blue-brush</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">brush%</span> <span class="p">[</span><span class="nf">color</span> <span class="s">"blue"</span><span class="p">]))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">yellow-brush</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">brush%</span> <span class="p">[</span><span class="nf">color</span> <span class="s">"yellow"</span><span class="p">]))</span>


<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-z-point</span> <span class="nv">dc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="nv">no-pen</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-brush</span> <span class="nv">blue-brush</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">ga</span> <span class="p">⥆</span> <span class="mi">8</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">pa</span> <span class="p">⥆</span> <span class="mi">8</span><span class="p">}</span>
  <span class="p">{</span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">to-screen-multi-values</span> <span class="nv">z</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">x</span> <span class="p">←</span> <span class="p">{</span><span class="nv">x</span> <span class="nv">-</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">ga</span> <span class="mi">2</span><span class="p">)</span><span class="p">}}</span>
  <span class="p">{</span><span class="nv">y</span> <span class="p">←</span> <span class="p">{</span><span class="nv">y</span> <span class="nv">-</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">pa</span> <span class="mi">2</span><span class="p">)</span><span class="p">}}</span>
  <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-ellipse</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">ga</span> <span class="nv">pa</span><span class="p">))</span>

<span class="c1">;; convert to screen coords</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">to-screen</span> <span class="nv">z0</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">re</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">real-part</span> <span class="nv">z0</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">im</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">imag-part</span> <span class="nv">z0</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">xs</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">re</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">{</span><span class="nv">ys</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">im</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">(</span><span class="nb">make-rectangular</span> <span class="p">(</span><span class="nb">round</span> <span class="p">{</span><span class="nv">xo</span> <span class="nv">+</span> <span class="nv">xs</span><span class="p">}</span><span class="p">)</span>
		    <span class="p">(</span><span class="nb">round</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">-</span> <span class="nv">ys</span><span class="p">}</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">to-screen-multi-values</span> <span class="nv">z0</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">re</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">real-part</span> <span class="nv">z0</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">im</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">imag-part</span> <span class="nv">z0</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">xs</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">re</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">{</span><span class="nv">ys</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">im</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">round</span> <span class="p">{</span><span class="nv">xo</span> <span class="nv">+</span> <span class="nv">xs</span><span class="p">}</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">round</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">-</span> <span class="nv">ys</span><span class="p">}</span><span class="p">)))</span>



<span class="c1">;;{z ⥆ 0}</span>
<span class="c1">;;{z ⥆ 2+1i}</span>
<span class="p">{</span><span class="nv">z</span> <span class="p">⥆</span> <span class="mf">1.13</span><span class="nv">+1</span><span class="o">.</span><span class="mi">765</span><span class="nv">i</span><span class="p">}</span>


<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-zeta</span> <span class="nv">dc</span><span class="p">)</span>
  
  <span class="p">{</span><span class="nv">zi</span> <span class="p">⥆</span> <span class="mi">0</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">nmax</span> <span class="p">⥆</span> <span class="mi">10000000</span><span class="p">}</span>
  
  <span class="p">{</span><span class="nv">flag-color</span> <span class="p">⥆</span> <span class="no">#t</span><span class="p">}</span>
  <span class="c1">;;(newline)</span>
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">n</span> <span class="mi">1</span> <span class="nv">nmax</span><span class="p">)</span>
       <span class="p">(</span><span class="k">if</span> <span class="nv">flag-color</span>
	   <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="s">"blue"</span> <span class="mi">1</span> <span class="ss">'solid</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="s">"green"</span> <span class="mi">1</span> <span class="ss">'solid</span><span class="p">))</span>
       <span class="p">{</span><span class="nv">flag-color</span> <span class="p">←</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">flag-color</span><span class="p">)</span><span class="p">}</span>
       <span class="c1">;;(display "draw-zeta : n =") (display n) (newline)</span>
       <span class="p">{</span><span class="nv">zp</span> <span class="p">⥆</span> <span class="p">{</span><span class="mf">1.0</span> <span class="nv">/</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">**</span> <span class="nv">z</span><span class="p">}}}</span>
       <span class="c1">;; (display "draw-zeta : z =") (display z) (newline)</span>
       <span class="c1">;; (display "draw-zeta : zp =") (display zp) (newline)</span>
       <span class="c1">;; (display "draw-zeta : zi =") (display zi) (newline)</span>
       <span class="p">{</span><span class="nv">zxtrm</span>  <span class="p">⥆</span> <span class="p">{</span><span class="nv">zi</span> <span class="nv">+</span> <span class="nv">zp</span><span class="p">}}</span>
       <span class="c1">;;(display "draw-zeta : zxtrm =") (display zxtrm) (newline)</span>
       <span class="p">{</span><span class="nv">zie</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">to-screen</span> <span class="nv">zi</span><span class="p">)</span><span class="p">}</span>
       <span class="c1">;;(display "draw-zeta : zie =") (display zie) (newline)</span>
       <span class="p">{</span><span class="nv">zxtrme</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">to-screen</span> <span class="nv">zxtrm</span><span class="p">)</span><span class="p">}</span>
       <span class="c1">;;(display "draw-zeta : zxtrme =") (display zxtrme) (newline)</span>
       <span class="p">{</span><span class="nv">x0</span> <span class="p">⥆</span>  <span class="p">(</span><span class="nb">real-part</span> <span class="nv">zie</span><span class="p">)</span><span class="p">}</span>
       <span class="p">{</span><span class="nv">y0</span> <span class="p">⥆</span>  <span class="p">(</span><span class="nb">imag-part</span> <span class="nv">zie</span><span class="p">)</span><span class="p">}</span>
       <span class="p">{</span><span class="nv">x1</span> <span class="p">⥆</span>  <span class="p">(</span><span class="nb">real-part</span> <span class="nv">zxtrme</span><span class="p">)</span><span class="p">}</span>
       <span class="p">{</span><span class="nv">y1</span> <span class="p">⥆</span>  <span class="p">(</span><span class="nb">imag-part</span> <span class="nv">zxtrme</span><span class="p">)</span><span class="p">}</span>
       <span class="p">(</span><span class="nf">when</span> <span class="p">{</span> <span class="p">{</span><span class="nv">x0</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">x0</span> <span class="nv">&lt;=</span> <span class="nv">xws</span><span class="p">}</span> <span class="nv">and</span>  <span class="p">{</span><span class="nv">x1</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">x1</span> <span class="nv">&lt;=</span> <span class="nv">xws</span><span class="p">}</span>
	      <span class="nv">and</span> <span class="p">{</span><span class="nv">y0</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">y0</span> <span class="nv">&lt;=</span> <span class="nv">ywsp</span><span class="p">}</span> <span class="nv">and</span>  <span class="p">{</span><span class="nv">y1</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">y1</span> <span class="nv">&lt;=</span> <span class="nv">ywsp</span><span class="p">}}</span>
	     <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
		   <span class="nv">x0</span> <span class="nv">y0</span>
		   <span class="nv">x1</span> <span class="nv">y1</span><span class="p">))</span>
       <span class="p">{</span><span class="nv">zi</span> <span class="p">←</span> <span class="nv">zxtrm</span><span class="p">}</span><span class="p">))</span>


<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-zeta-multi-values</span> <span class="nv">dc</span><span class="p">)</span>
  
  <span class="p">{</span><span class="nv">zi</span> <span class="p">⥆</span> <span class="mi">0</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">flag-color</span> <span class="p">⥆</span> <span class="no">#t</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">dmin</span> <span class="p">⥆</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">;; minimal length  in pixel to draw line</span>
  <span class="p">{</span><span class="nv">n</span> <span class="p">⥆</span> <span class="mi">1</span><span class="p">}</span>
  <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  
  <span class="p">(</span><span class="nf">repeat</span>
   
       <span class="p">(</span><span class="k">if</span> <span class="nv">flag-color</span>
	   <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="s">"blue"</span> <span class="mi">1</span> <span class="ss">'solid</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="s">"green"</span> <span class="mi">1</span> <span class="ss">'solid</span><span class="p">))</span>
       <span class="p">{</span><span class="nv">flag-color</span> <span class="p">←</span> <span class="p">(</span><span class="nb">not</span> <span class="nv">flag-color</span><span class="p">)</span><span class="p">}</span>
       <span class="c1">;;(display "draw-zeta-multi-values : n =") (display n) (newline)</span>
       <span class="p">{</span><span class="nv">zp</span> <span class="p">⥆</span> <span class="p">{</span><span class="mf">1.0</span> <span class="nv">/</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">**</span> <span class="nv">z</span><span class="p">}}}</span>
       <span class="p">{</span><span class="nv">zxtrm</span>  <span class="p">⥆</span> <span class="p">{</span><span class="nv">zi</span> <span class="nv">+</span> <span class="nv">zp</span><span class="p">}}</span>
       <span class="c1">;;(display "draw-zeta-multi-values : zxtrm =") (display zxtrm) (newline)</span>
 
       <span class="p">{</span><span class="p">(</span><span class="nf">x0</span> <span class="nv">y0</span><span class="p">)</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">to-screen-multi-values</span> <span class="nv">zi</span><span class="p">)</span><span class="p">}</span> 
       <span class="p">{</span><span class="p">(</span><span class="nf">x1</span> <span class="nv">y1</span><span class="p">)</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">to-screen-multi-values</span> <span class="nv">zxtrm</span><span class="p">)</span><span class="p">}</span>
 
       <span class="p">(</span><span class="nf">when</span> <span class="p">{</span> <span class="p">{</span><span class="nv">x0</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">x0</span> <span class="nv">&lt;=</span> <span class="nv">xws</span><span class="p">}</span> <span class="nv">and</span>  <span class="p">{</span><span class="nv">x1</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">x1</span> <span class="nv">&lt;=</span> <span class="nv">xws</span><span class="p">}</span>
	      <span class="nv">and</span> <span class="p">{</span><span class="nv">y0</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">y0</span> <span class="nv">&lt;=</span> <span class="nv">ywsp</span><span class="p">}</span> <span class="nv">and</span>  <span class="p">{</span><span class="nv">y1</span> <span class="nv">&gt;=</span> <span class="mi">0</span><span class="p">}</span> <span class="nv">and</span> <span class="p">{</span><span class="nv">y1</span> <span class="nv">&lt;=</span> <span class="nv">ywsp</span><span class="p">}}</span>
	     <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
		   <span class="nv">x0</span> <span class="nv">y0</span>
		   <span class="nv">x1</span> <span class="nv">y1</span><span class="p">))</span>

       <span class="p">{</span><span class="nv">len-line</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">line-length</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">x1</span> <span class="nv">y1</span><span class="p">)</span><span class="p">}</span>
       <span class="p">{</span><span class="nv">zi</span> <span class="p">←</span> <span class="nv">zxtrm</span><span class="p">}</span>
       <span class="p">{</span><span class="nv">n</span> <span class="p">←</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">+</span> <span class="mi">1</span><span class="p">}}</span>
       
       <span class="nv">until</span> <span class="p">{</span><span class="nv">len-line</span> <span class="nv">&lt;</span> <span class="nv">dmin</span><span class="p">}</span><span class="p">)</span>

  <span class="p">(</span><span class="nb">display</span> <span class="s">"draw-zeta-multi-values : z ="</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">"draw-zeta-multi-values : Riemann Zeta(z) = zi ="</span><span class="p">)</span> <span class="p">(</span><span class="nb">display</span> <span class="nv">zi</span><span class="p">)</span> <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>

  <span class="p">)</span>



<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">line-length</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">x1</span> <span class="nv">y1</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sqrt</span> <span class="p">{</span> <span class="p">{</span> <span class="p">{</span><span class="nv">x1</span> <span class="nv">-</span> <span class="nv">x0</span><span class="p">}</span> <span class="nv">**</span> <span class="mi">2</span><span class="p">}</span> <span class="nv">+</span> <span class="p">{</span> <span class="p">{</span><span class="nv">y1</span> <span class="nv">-</span> <span class="nv">y0</span><span class="p">}</span> <span class="nv">**</span> <span class="mi">2</span><span class="p">}}</span><span class="p">))</span>


<span class="c1">;; (new button% [parent frame0]</span>
<span class="c1">;;              [label "Pause"]</span>
<span class="c1">;;              [callback (λ (button event) (sleep 5))])</span>


<span class="c1">;; {panel ⥆ (new horizontal-panel% [parent frame0])}</span>

<span class="c1">;; (new button% [parent panel]</span>
<span class="c1">;;              [label "Left"]</span>
<span class="c1">;;              [callback (λ (button event)</span>
<span class="c1">;;                          (send msg set-label "Left click"))])</span>
<span class="c1">;; (new button% [parent panel]</span>
<span class="c1">;;              [label "Right"]</span>
<span class="c1">;;              [callback (λ (button event)</span>
<span class="c1">;;                          (send msg set-label "Right click"))])</span>

<span class="p">{</span><span class="nv">z-old</span> <span class="p">⥆</span> <span class="nv">z</span><span class="p">}</span>

<span class="c1">; Derive a new canvas (a drawing window) class to handle events</span>
<span class="p">{</span><span class="nv">my-canvas%</span> <span class="p">⥆</span>
  <span class="p">(</span><span class="nf">class</span> <span class="nv">canvas%</span> <span class="c1">; The base class is canvas%</span>
    <span class="c1">; Define overriding method to handle mouse events</span>
    <span class="p">(</span><span class="nf">define/override</span> <span class="p">(</span><span class="nf">on-event</span> <span class="nv">event</span><span class="p">)</span>
     
      <span class="p">{</span><span class="nv">window-x</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">send</span> <span class="nv">event</span> <span class="nv">get-x</span><span class="p">)</span><span class="p">}</span>
      <span class="p">{</span><span class="nv">window-y</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">send</span> <span class="nv">event</span> <span class="nv">get-y</span><span class="p">)</span><span class="p">}</span>
      <span class="p">(</span><span class="nf">when</span> <span class="nv">animation-mode</span>
	<span class="p">{</span><span class="nv">z</span> <span class="p">←</span> <span class="p">(</span><span class="nf">ret-z</span> <span class="nv">window-x</span> <span class="nv">window-y</span><span class="p">)</span><span class="p">}</span><span class="p">)</span>
      
      <span class="c1">;;{str ⥆ (string-append "(" (number-&gt;string window-x) " , " (number-&gt;string window-y) ")")}</span>
      <span class="p">(</span><span class="nf">when</span> <span class="p">{</span><span class="nv">z</span> <span class="p">≠</span> <span class="nv">z-old</span><span class="p">}</span>
	    <span class="p">{</span><span class="nv">z-old</span> <span class="p">←</span> <span class="nv">z</span><span class="p">}</span>
	    <span class="p">{</span><span class="nv">str</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">number-&gt;string</span> <span class="nv">z</span><span class="p">)</span><span class="p">}</span> 
	    <span class="p">(</span><span class="nf">send</span> <span class="nv">msg</span> <span class="nv">set-label</span> <span class="nv">str</span><span class="p">)</span>
	    <span class="p">(</span><span class="nf">send</span> <span class="nv">cv</span> <span class="nv">refresh</span><span class="p">))</span>
      
      <span class="p">)</span>
    
    <span class="c1">; Define overriding method to handle keyboard events</span>
    <span class="p">(</span><span class="nf">define/override</span> <span class="p">(</span><span class="nf">on-char</span> <span class="nv">event</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">send</span> <span class="nv">msg</span> <span class="nv">set-label</span> <span class="s">"Canvas keyboard"</span><span class="p">))</span>
    <span class="c1">; Call the superclass init, passing on all init args</span>
    <span class="p">(</span><span class="nf">super-new</span><span class="p">))</span><span class="p">}</span>


<span class="p">{</span><span class="nv">cv</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">new</span> <span class="nv">my-canvas%</span> <span class="p">[</span><span class="nf">parent</span> <span class="nv">frame0</span><span class="p">]</span>
	   <span class="p">[</span><span class="nf">paint-callback</span>
	    <span class="p">(</span><span class="p">λ</span> <span class="p">(</span><span class="nf">canvas</span> <span class="nv">dc</span><span class="p">)</span> <span class="c1">;; dc: Drawing Context</span>
	      <span class="c1">;; cf. https://docs.racket-lang.org/draw/overview.html#%28tech._drawing._context%29</span>
	      
	      <span class="c1">;; (send dc draw-rectangle</span>
	      <span class="c1">;; 	    (random 10) 10   ; Top-left at (0, 10), 10 pixels down from top-left</span>
	      <span class="c1">;; 	    30 10) ; 30 pixels wide and 10 pixels high</span>
	      <span class="c1">;; (send dc draw-line</span>
	      <span class="c1">;; 	    (random 10) 0    ; Start at (0, 0), the top-left corner</span>
	      <span class="c1">;; 	    30 30) ; and draw to (30, 30), the bottom-right corner</span>

	      <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">erase</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">set-pen</span> <span class="s">"black"</span> <span class="mi">1</span> <span class="ss">'solid</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">draw-axes</span> <span class="nv">dc</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">draw-units</span> <span class="nv">dc</span><span class="p">)</span>
	      <span class="p">(</span><span class="nf">draw-z-point</span> <span class="nv">dc</span><span class="p">)</span>

	      <span class="p">(</span><span class="k">if</span> <span class="nv">animation-mode</span>
		  <span class="p">(</span><span class="nf">draw-zeta-multi-values</span> <span class="nv">dc</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">draw-zeta</span> <span class="nv">dc</span><span class="p">))</span>
	      
	      <span class="c1">;; (send dc set-scale 3 3)</span>
	      <span class="c1">;; (send dc set-text-foreground "blue")</span>
	      <span class="c1">;; (send dc draw-text "Don't Panic!" 0 0)</span>
	      <span class="p">)])</span><span class="p">}</span>




<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">center-coords</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">xws</span> <span class="mi">2</span><span class="p">)</span>
	  <span class="p">(</span><span class="nb">quotient</span> <span class="nv">ywsp</span> <span class="mi">2</span><span class="p">)))</span>

<span class="p">{</span><span class="p">(</span><span class="nf">xo</span> <span class="nv">yo</span><span class="p">)</span> <span class="p">⥆</span> <span class="p">(</span><span class="nf">center-coords</span><span class="p">)</span><span class="p">}</span>

<span class="p">{</span><span class="nv">unit</span> <span class="p">⥆</span> <span class="mi">200</span><span class="p">}</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-axes</span> <span class="nv">dc</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span> <span class="c1">;; Ox</span>
	<span class="mi">0</span> <span class="nv">yo</span> <span class="nv">xws</span> <span class="nv">yo</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span> <span class="c1">;; Oy</span>
	<span class="nv">xo</span> <span class="mi">0</span> <span class="nv">xo</span> <span class="nv">ywsp</span><span class="p">))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">draw-units</span> <span class="nv">dc</span><span class="p">)</span>
  <span class="c1">;;X</span>
  <span class="p">{</span><span class="nv">nun</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">xo</span> <span class="nv">unit</span><span class="p">)</span><span class="p">}</span>
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">n</span> <span class="mi">1</span> <span class="nv">nun</span><span class="p">)</span>
       <span class="p">{</span><span class="nv">xu</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">xo</span> <span class="nv">+</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}}</span>
       <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
	     <span class="nv">xu</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">-</span> <span class="mi">3</span><span class="p">}</span>
	     <span class="nv">xu</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">+</span> <span class="mi">3</span><span class="p">}</span><span class="p">)</span>
       <span class="p">{</span><span class="nv">xum</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">xo</span> <span class="nv">-</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}}</span>
       <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
	     <span class="nv">xum</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">-</span> <span class="mi">3</span><span class="p">}</span>
	     <span class="nv">xum</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">+</span> <span class="mi">3</span><span class="p">}</span><span class="p">))</span>

  <span class="c1">;; Y</span>
  <span class="p">{</span><span class="nv">nuny</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">quotient</span> <span class="nv">yo</span> <span class="nv">unit</span><span class="p">)</span><span class="p">}</span>
  <span class="p">(</span><span class="nf">for</span> <span class="p">(</span><span class="nf">n</span> <span class="mi">1</span> <span class="nv">nuny</span><span class="p">)</span>
       <span class="p">{</span><span class="nv">yu</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">-</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}}</span>
       <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
	     <span class="p">{</span><span class="nv">xo</span> <span class="nv">-</span> <span class="mi">3</span><span class="p">}</span> <span class="nv">yu</span>
	     <span class="p">{</span><span class="nv">xo</span> <span class="nv">+</span> <span class="mi">3</span><span class="p">}</span> <span class="nv">yu</span><span class="p">)</span>
       <span class="p">{</span><span class="nv">yum</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">yo</span> <span class="nv">+</span> <span class="p">{</span><span class="nv">n</span> <span class="nv">*</span> <span class="nv">unit</span><span class="p">}}}</span>
       <span class="p">(</span><span class="nf">send</span> <span class="nv">dc</span> <span class="nv">draw-line</span>
	     <span class="p">{</span><span class="nv">xo</span> <span class="nv">-</span> <span class="mi">3</span><span class="p">}</span> <span class="nv">yum</span>
	     <span class="p">{</span><span class="nv">xo</span> <span class="nv">+</span> <span class="mi">3</span><span class="p">}</span> <span class="nv">yum</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">send</span> <span class="nv">frame0</span> <span class="nv">show</span> <span class="no">#t</span><span class="p">)</span>

<span class="c1">;; return the z complex from canvas plane where is the mouse pointer</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ret-z</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">{</span><span class="nv">i</span> <span class="p">⥆</span> <span class="mi">0</span><span class="nv">+1i</span><span class="p">}</span> <span class="c1">;; imaginaire pur</span>
  <span class="p">{</span><span class="nv">re</span> <span class="p">⥆</span> <span class="p">{</span><span class="nv">x</span> <span class="nv">-</span> <span class="nv">xo</span><span class="p">}}</span>
  <span class="p">{</span><span class="nv">re</span> <span class="p">←</span> <span class="p">{</span><span class="nv">re</span> <span class="nv">/</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">{</span><span class="nv">im</span> <span class="p">⥆</span> <span class="p">(</span><span class="nb">-</span> <span class="p">{</span><span class="nv">y</span> <span class="nv">-</span> <span class="nv">yo</span><span class="p">}</span><span class="p">)</span><span class="p">}</span>
  <span class="p">{</span><span class="nv">im</span> <span class="p">←</span> <span class="p">{</span><span class="nv">im</span> <span class="nv">/</span> <span class="nv">unit</span><span class="p">}}</span>
  <span class="p">(</span><span class="nb">exact-&gt;inexact</span> <span class="p">{</span><span class="nv">re</span> <span class="nv">+</span> <span class="p">{</span><span class="nv">i</span> <span class="nv">*</span> <span class="nv">im</span><span class="p">}}</span><span class="p">))</span>

<span class="o"></span></code></pre>
          </figure>
          <br>
          <br>
          <p align="center"><br>
          </p>
          <div align="center"><img
              src="Scheme+io_fichiers/zeta-DrRacket.png"
              moz-do-not-send="true" alt="zeta riemann" width="1200"
              border="3" height="750"><br>
          </div>
          <br>
          <br>
          <br>
          Scheme+ by Damien Mattei
        </div>
        <p></p>
      </section>
    </div>
  </body>
</html>
